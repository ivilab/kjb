#!/bin/csh -f 

##############################################################################
#
# Identification:
#     A script to execute commands so that only one instance is run at a time. 
#
# Description:
#     This is a simple script for locking. It trades limited capability for
#     simplicity (see deficiencies below). Using it is a lot like using "flock",
#     and in fact, it is implemented using "flock" if flock is available. The
#     main justification for this script is that locking is not universally
#     available, most notably good locking facilities are not available in the
#     mac OS. Hence, this script implements a fall back method that is less than
#     ideal, but usually works. 
#
#     The argument to kjb_lock is the command to be executed including its
#     arguments. Unlike flock, the lockfile need not (and cannot at this time)
#     be specified. Instead, we use the command name, and part of the directory
#     to create a lock. 
#
#     Unlike flock, this script sets an environment variable KJB_LOCK_TIME_STAMP
#     that holds the path to a process specific file that timestamps the locking
#     process. This environment variable is (only) available to the command
#     that kjb_lock executes. The purpose of this is to enable processes that
#     are all hoping to modify the same resource to test the modification time
#     against the lock time stamp, and back off from modifying it if it is
#     newer than  the lock. 
#
#     If the environment variable KJB_LOCKING_METHOD is set, this script will
#     use its value for the locking method. Otherwise it will try flock, then
#     lockfile-progs, and then the built in fall back method. 
#
#     If the environment variable KJB_LOCKFILE_PATH is set, this script will use
#     its value as a directory to create lockfiles in. Otherwise, this script
#     will use ${TMPDIR}/${USER}/lockfiles/, creating it if needed.
#
# Deficiencies
#     In the future, we should be able to specify a resource to be locked,
#     possible as a environment variable (crude, but by far the easiest to
#     implement).  The current implementation locks all runs of a command in a
#     given sub-directory, irrespective of arguments or parent directory, which
#     is is not a big issue as it is simply overly conservative. More of
#     potential issue is that there might be different ways to modify a
#     resource, in which case we should lock the resource. However, sometimes
#     the action is not described as modifying an obvious resource (e.g.,
#     updating an SVN repo), and hence we would like to have both behaviors
#
# Author:
#     Kobus Barnard 
#
##############################################################################

# set echo

if ($# < 1) then
    ${P_STDERR} "Script kjb_lock needs at least one argument."
    exit 1
endif 

set exit_status = 0

if ($?KJB_VERBOSE) then
    if ($?KJB_VERBOSE_INDENT) then
        set verbose_indent = "${KJB_VERBOSE_INDENT}"
    else
        set verbose_indent = ""
    endif
endif 

if (! $?KJB_LOCKING_METHOD) then
    # Sync this code with that in init_compile!

    if (`${MAKE_SCRIPT_PATH}can_execute flock`) then
        kjb_setenv KJB_LOCKING_METHOD "flock" 
    else if ((`${MAKE_SCRIPT_PATH}can_execute lockfile-create`) && (`${MAKE_SCRIPT_PATH}can_execute lockfile-remove`)) then
        kjb_setenv KJB_LOCKING_METHOD "lockfile-progs" 
    else
        kjb_setenv KJB_LOCKING_METHOD "fallback"
    endif 
endif 

set dir_str = `echo ${cwd} | sed 's#.*/##'`
set cmd_str = `echo ${1} | sed 's#.*/##'`

if (! $?KJB_LOCKFILE_PATH) then
    setenv KJB_LOCKFILE_PATH ${TMPDIR}/${USER}/lockfiles/
endif 

${KJB_MKDIR} "${KJB_LOCKFILE_PATH}"

if ($status) then
    $P_STDERR "Unable to make directory ${KJB_LOCKFILE_PATH}"
    exit 1
endif 

set lock_file = ${KJB_LOCKFILE_PATH}/${cmd_str}_${dir_str}.lock

setenv KJB_LOCK_TIME_STAMP "${KJB_LOCKFILE_PATH}/${cmd_str}_${dir_str}.lock.$$"
${KJB_TOUCH} ${KJB_LOCK_TIME_STAMP}

onintr bail

# Best not to use VERBOSE_PSO here.
if ($?KJB_VERBOSE) then
    echo "${verbose_indent}Script kjb_lock process $$ running ${cmd_str}"
    echo "${verbose_indent}    in `pwd` using lockfile '${lock_file}'"
endif

if  ("${KJB_LOCKING_METHOD}" == "flock") then
    # Best not to use VERBOSE_PSO here.
    if ($?KJB_VERBOSE) then
        echo "${verbose_indent}Process $$ running ${cmd_str} in `pwd` using 'flock'"
    endif

    flock ${lock_file} $*
    set exit_status = ${status}

    if (! ${exit_status}) then
        # Best not to use VERBOSE_PSO here.
        if ($?KJB_VERBOSE) then
            echo "${verbose_indent}Process $$ successfully ran ${cmd_str} in `pwd` using 'flock'"
        endif
    endif
else if ("${KJB_LOCKING_METHOD}" == "lockfile-progs") then
    # if ($?KJB_VERBOSE) then
        echo "Process $$ running ${cmd_str} in `pwd` using lockfile-progs"
    # endif 
#     echo "Exiting with error as this is unfinished."
#     exit 1

    lockfile-create ${lock_file}
    $*
    set exit_status = $status 
    lockfile-remove ${lock_file}

    if (! ${exit_status}) then 
        # Best not to use VERBOSE_PSO here.
        if ($?KJB_VERBOSE) then
            echo "${verbose_indent}Process $$ successfully ran ${cmd_str} in `pwd` using lockfile-progs locking method."
        endif
    endif 
else 
    # Fallback locking method. Doing locking robustly in scripts is hard, but
    # often (e.g., mac) we do not have a good solution. The following is better
    # than nothing.

    # Best not to use VERBOSE_PSO here.
    if ($?KJB_VERBOSE) then
        echo "${verbose_indent}Process $$ running ${cmd_str} in `pwd` using fallback locking system."
    endif

    # Reduce the chances of everyone wanting to start at the same time.
    # I do not know how likely this is to fail, or even to return success
    # without doing the right thing, but it seems to work on the mac. 
    set x = $$ ; @ x %= 100 ; sleep 0.$x >& /dev/null
    if (${status}) then
        ${P_STDERR} "Fractional sleep failed in kjb_lock." 
        set exit_status = 1
        goto cleanup
    endif

    if (! -e "${lock_file}") then
        echo $$ >! ${lock_file}

        if ($?KJB_VERBOSE) then
            echo "${verbose_indent}Process $$ setting lock file ${lock_file}."
            # ps -l $$
        endif 
    else 
        set count = 0
        set got_it = 0

        while (-e "${lock_file}")
            set lock_proc = `cat ${lock_file}`

            # Happens! 
            if ($status) then 
                echo $$ >! ${lock_file}
                echo "Lock file ${lock_file} disappeared! Taking the lock."
                set got_it = 1
                break
            endif 

            if ($?KJB_VERBOSE_2) then
                echo "${verbose_indent}Lock file ${lock_file} exists."
                echo "${verbose_indent}Checking on lock file process ${lock_proc}." 
            endif 

            ps ${lock_proc} >& /dev/null
            set ps_status = "${status}" 

            if (${ps_status}) then
                echo $$ >! ${lock_file}

                if ($?KJB_VERBOSE) then
                    echo "${verbose_indent}Process $$ resetting lock file ${lock_file} as process ${lock_proc} does not exist."
                endif 

                set got_it = 1
                break
            else if (${count} > 180) then
                echo "Process $$ waited too long for ${lock_file}. "
                echo "Information about the process holding the lock:"
                ps -l ${lock_proc} 
                echo "Sleeping for one minute for debugging" 
                sleep 60
                echo "Ignoring the lock."
                echo $$ >! ${lock_file}
                set got_it = 1
                break
            else  
                if ($?KJB_VERBOSE) then
                    echo "${verbose_indent}Process $$ waiting for ${lock_file} held by process ${lock_proc}."
                endif 

                # Add some fractional seconds to reduce the chances of everyone
                # wanting to start at the same time.
                set x = $$ ; @ x %= 100 ; sleep 1.$x >& /dev/null
                if (${status}) then
                    ${P_STDERR} "Fractional sleep failed in kjb_lock." 
                    set exit_status = 1
                    goto cleanup
                endif

                @ count ++
            endif
        end

        # If we got_it is still false, then the lock file was removed by the
        # process we were waiting on.
        #
        if (! ${got_it}) then
            echo $$ >! ${lock_file}

            if ($?KJB_VERBOSE) then
                echo "${verbose_indent}Process $$ setting lock file ${lock_file} as it no longer exists."
            endif 
        endif 
    endif 

    # Run the command
    $*
    set exit_status = $status

    ${KJB_RM} "${lock_file}"
   
    if (${exit_status}) exit 1

    # Best not to use VERBOSE_PSO here.
    if ($?KJB_VERBOSE) then
        echo "${verbose_indent}Process $$ successfully ran ${cmd_str} in `pwd` using fallback locking method."
    endif
endif 

cleanup: 
    
${KJB_RM} ${KJB_LOCK_TIME_STAMP}

exit ${exit_status}


# We should not be here unless onintr

bail:

if (-e "${lock_file}") then 
    echo "Script kjb_lock process $$ removing lock file ${lock_file} because of interrupt."
    echo " "
    ${KJB_RM} "${lock_file}"
endif 

${KJB_RM} ${KJB_LOCK_TIME_STAMP}

exit 1


   
