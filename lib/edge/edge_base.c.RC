/* $Id: edge_base.c 13420 2012-12-07 18:09:10Z predoehl $ */
/**
 * @file
 * @author Joe Schlecht
 * @author Kyle Simek
 * @author Andrew Predoehl
 *
 * @warning This file is only a Release Candidate, not ready for production.
 *
 * This work is licensed under a Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 United States License.
 *
 *    http://creativecommons.org/licenses/by-nc-sa/3.0/us/
 *
 * You are free:
 *
 *    to Share - to copy, distribute, display, and perform the work
 *    to Remix - to make derivative works
 *
 * Under the following conditions:
 *
 *    Attribution. You must attribute the work in the manner specified by the
 *    author or licensor (but not in any way that suggests that they endorse you
 *    or your use of the work).
 *
 *    Noncommercial. You may not use this work for commercial purposes.
 *
 *    Share Alike. If you alter, transform, or build upon this work, you may
 *    distribute the resulting work only under the same or similar license to
 *    this one.
 *
 * For any reuse or distribution, you must make clear to others the license
 * terms of this work. The best way to do this is with a link to this web page.
 *
 * Any of the above conditions can be waived if you get permission from the
 * copyright holder.
 *
 * Apart from the remix rights granted under this license, nothing in this
 * license impairs or restricts the author's moral rights.
 */

/* =========================================================================== *
   |
   |  Copyright (c) 1994-2010 by Kobus Barnard (author)
   |
   |  Personal and educational use of this code is granted, provided that this
   |  header is kept intact, and that the authorship is not misrepresented, that
   |  its use is acknowledged in publications, and relevant papers are cited.
   |
   |  For other use contact the author (kobus AT cs DOT arizona DOT edu).
   |
   |  Please note that the code in this file has not necessarily been adequately
   |  tested. Naturally, there is no guarantee of performance, support, or fitness
   |  for any particular task. Nonetheless, I am interested in hearing about
   |  problems that you encounter.
   |
   |  Author: Joe Schlecht, Kyle Simek
 * =========================================================================== */


#include "l/l_incl.h"
#include "i/i_float.h"
#include "i/i_float_io.h"
#include "m/m_vector.h"
#include "i/i_matrix.h"
#include "m/m_matrix.h"
#include "m/m_mat_basic.h"
#include "m/m_convolve.h"
#include "m2/m2_ncc.h"
#include "edge/edge_base.h"


#define KJB_EDGE_MAX_RGB_VALUE 255

#ifdef __cplusplus
extern "C" {
#ifdef COMPILING_CPLUSPLUS_SOURCE
namespace kjb_c {
#endif
#endif

/* The following is the smallest positive real value we are willing to risk
 * dividing by.
 */
#define SMALLEST_DIVISOR (1.0e-8)

static Edge_set* create_blank_edge_set(
    uint32_t num_edges,
    uint32_t num_points
);

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                                free_edge_list
 *
 * Linked list node containing an edge point.
 *
 * =============================================================================
 */
typedef struct Edge_list
{
    /** @brief Edge point in the list node. */
    Edge_point* pt;

    /** @brief Next edge list node. */
    struct Edge_list* next;
}
Edge_list;


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                         free_edge_list
 *
 * Frees an edge_list
 *
 * =============================================================================
 */
static void free_edge_list(Edge_list* edges)
{
    Edge_list* next;

    next = edges->next;

    kjb_free(edges->pt);
    kjb_free(edges);

    if (next)
    {
        free_edge_list(next);
    }
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                       assign_edge_set_edges
 *
 * Copy the edges of one edge_set into another.  This leaves two pointers both
 * pointing to the same block of memory, a conflict that must be resolved
 * elsewhere.
 * =============================================================================
 */
static void assign_edge_set_edges( Edge_set *dest_set, const Edge_set *src_set )
{
    ASSERT( dest_set != NULL && src_set != NULL );
    dest_set -> edges = src_set -> edges;
    dest_set -> num_edges = src_set -> num_edges;
    dest_set -> total_num_pts = src_set -> total_num_pts;
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                       swap_edge_set_edges
 *
 * Swap the edges arrays of two Edge_sets; any ancillary fields in Edge_set
 * are untouched (currently that's just num_rows, num_cols but it could grow).
 * =============================================================================
 */
static void swap_edge_set_edges( Edge_set *set1, Edge_set *set2 )
{
    Edge_set temp;
    ASSERT( set1 != NULL && set2 != NULL );
    temp = *set1;
    assign_edge_set_edges( set1, set2 );
    assign_edge_set_edges( set2, &temp );
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */


/* =============================================================================
 * STATIC                      clear_edge_set
 *
 * Remove all points from an edge set.
 * =============================================================================
 */
static int clear_edge_set( Edge_set *edge_set )
{
    NRE( edge_set );
    if ( 0 < edge_set -> num_edges )
    {
        ASSERT( edge_set -> edges );
        kjb_free( edge_set -> edges -> points );
        kjb_free( edge_set -> edges );
        edge_set -> edges = NULL;
        edge_set -> num_edges = 0;
        edge_set -> total_num_pts = 0;
    }
    ASSERT( NULL == edge_set -> edges );
    return NO_ERROR;
}


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */


/* =============================================================================
 *                  get_target_edge_set
 *
 * Perform memory allocation for Edge_set, according to library conventions.
 *
 * Returns:
 *    NO_ERROR on success, and ERROR on failure, with an appropriate error
 *    message being set.  In case of ERROR, the edge set is returned unchanged.
 *
 * If the input indicates an edge set pointer equal to null, then new memory
 * is allocated.  Otherwise, the old values in the Edge_set are preserved,
 * except for the edges field.  If possible, previous storage space is
 * recycled, unless 'num_edges' is zero.
 *
 * If 'num_edges' is zero, the edges field of the Edge_set is set to NULL.
 * Otherwise, edges points to an array of uninitialized memory; except that the
 * first Edge element has its 'points' field also set to an array of
 * uninitialized memory.  Both arrays are the requested size or else ERROR is
 * returned.
 * =============================================================================
 */
int get_target_edge_set(
    Edge_set** target_espp,
    uint32_t num_edges,
    uint32_t num_points
)
{
    Edge_set   *out_set;
    Edge       *out_edge;
    Edge_point *out_point;

    NRE( target_espp );
    out_set = *target_espp;

    /*
     * Every edge must have at least one edge point, and every edge point must
     * belong to an edge.
     */
    if ( num_points < num_edges || ( 0 == num_edges && 0 < num_points ) )
    {
        set_error("Bad size of Edge_set");
        return ERROR;
    }

    /* Trivial case 1:  input indicated a null pointer. */
    if ( NULL == out_set )
    {
        NRE( *target_espp = create_blank_edge_set( num_edges, num_points ) );
        return NO_ERROR;
    }

    /* Trivial case 2:  output is empty. */
    if ( 0 == num_edges )
    {
        return clear_edge_set( out_set );
    }
    out_edge = out_set -> edges;

    /* Easy case:  input is empty. */
    if ( 0 == out_set -> num_edges )
    {
        Edge_set *new_set;
        ASSERT( NULL == out_edge ); /* Is its claim of emptiness consistent? */
        NRE( new_set = create_blank_edge_set( num_edges, num_points ) );
        swap_edge_set_edges( out_set, new_set );
        free_edge_set( new_set );
        return NO_ERROR;
    }
    NRE( out_edge ); /* Claims to have edges?  It must have an edge array. */

    /* Both input and output have at least one Edge and Edge_point. */
    out_point = out_edge -> points;
    NRE( out_point ); /* out_edge non-NULL, out_point NULL == malformed! */

    /* First allocate Edge memory and Edge_point memory, nonmodifying. */
    if ( out_set -> num_edges < num_edges )
    {
        NRE( out_edge = N_TYPE_MALLOC( Edge, num_edges ) );
    }
    if ( out_set -> total_num_pts < num_points )
    {
        out_point = N_TYPE_MALLOC( Edge_point, num_points );
        if ( NULL == out_point && out_edge != out_set -> edges )
        {
            kjb_free( out_edge );
            return ERROR;
        }
    }

    /* Release obsolete memory, if any. */
    if ( out_point != out_set -> edges -> points )
    {
        kjb_free( out_set -> edges -> points );
    }
    if ( out_edge != out_set -> edges )
    {
        kjb_free( out_set -> edges );
    }
    /* Install new memory. */
    out_edge -> points = out_point;
    out_set -> edges = out_edge;

    out_set -> num_edges = num_edges;
    out_set -> total_num_pts = num_points;
    *target_espp = out_set;

    return NO_ERROR;
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                     create_blank_edge_set
 *
 * Allocate memory for an edge set or return NULL to indicate failure.
 *
 * Returns:
 *   NULL, if memory allocation fails, or a pointer to the new object.
 *
 * If successful, the return value p points to memory that is mostly left
 * uninitialized, except for the following fields:
 *
 * p->num_edges and p->total_num_pts get copies of the input arguments.
 * If num_edges is zero, then p->edges is set to NULL.  Otherwise, p->edges
 * points to a block of memory big enough to store the specified number of Edge
 * objects, and p->edges->points holds the address of another block of memory
 * big enough to store the specified number of Edge_points.  All other
 * memory locations are left uninitialized.  Of course, both of those blocks
 * of memory must be released using kjb_free() -- as free_edge_set() does.
 *
 * If memory allocation fails, this returns a NULL value.
 * =============================================================================
 */
static Edge_set* create_blank_edge_set(
    uint32_t num_edges,
    uint32_t num_points
)
{
    Edge_set* edge_set;

    /* Every edge must have at least one edge point. */
    ASSERT( num_edges <= num_points );
    ASSERT( 0 < num_edges || 0 == num_points );

    NRN( edge_set = TYPE_MALLOC( Edge_set ) );
    edge_set -> num_edges = num_edges;
    edge_set -> total_num_pts = num_points;

    if ( 0 == num_edges )
    {
        edge_set -> edges = NULL;
        return  edge_set;
    }

    edge_set -> edges = N_TYPE_MALLOC( Edge, num_edges );
    if ( NULL == edge_set -> edges )
    {
        kjb_free( edge_set );
        return NULL;
    }

    edge_set -> edges -> points = N_TYPE_MALLOC( Edge_point, num_points );
    if ( NULL == edge_set -> edges -> points )
    {
        kjb_free( edge_set -> edges );
        kjb_free( edge_set );
        return NULL;
    }

    return edge_set;
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                           realign_edges
 *
 * The points array can move in memory, but when that happens it makes all the
 * pointers in the edge array dangle.  However, if someone fixes the first one,
 * this routine will fix the followers.   Input argument 'count' should equal
 * the number of edge array entries with valid 'num_points' field. -- not the
 * number of broken pointers.
 *
 * The standard use-case for this function is after moving the points array,
 * for example with realloc().
 * =============================================================================
 */
static void realign_edges( Edge* edge_p, uint32_t count )
{
    Edge_point* pt;
    ASSERT( edge_p );
    pt = edge_p -> points;
    while( count-- > 0 )
    {
        ASSERT( edge_p );
        edge_p -> points = pt;
        pt += edge_p -> num_points;
        ++edge_p;
    }
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

static int handle_edge_realloc_failure(
    Edge_set** edge_set,
    const Edge_point* in_point, /* possibly dangling -- do NOT dereference */
    uint32_t new_total_pts
)
{
    uint32_t   old_num_edges, old_total_pts;
    Edge_point *out_point;
    Edge_set   *in_set;

    NRE( edge_set );

    UNTESTED_CODE();
    in_set = *edge_set;
    out_point = in_set -> edges -> points;
    old_num_edges = in_set -> num_edges;
    old_total_pts = in_set -> total_num_pts;

    if ( new_total_pts < old_total_pts )
    {
        /* We lost part of the old points array, but we could not build the
         * new edge array.  So we cannot backtrack to the previous state.
         * Maybe if we dispose of the corrupted structure responsibly,
         * the caller can recover.  It's a long shot.  Better squawk.
         */
        UNTESTED_CODE();
        test_pse("Edge_set realloc failed disastrously.  Sorry!  Freeing!");
        add_error("Halfway-successful realloc (structure corrupt)");
        free_edge_set( *edge_set );
        *edge_set = NULL;
        return ERROR;
    }

    add_error("Edge_set realloc failed halfway (structure unchanged).");

    /* From here on, we are in merely ordinary trouble:  allocation failed, but
     * the data structure is still essentially the same, although points
     * perhaps moved.  When we exit, we can claim the set is "unchanged."
     * Of course we still exit with an ERROR because of the allocation failure.
     */

    /* If we enlarged points, try to shrink it back to the size it was before.
     * I think this is likely to succeed.  If it doesn't, who cares!  Just keep
     * the bigger points array and let the unused tail lie idle.
     */
    if ( old_total_pts < new_total_pts )
    {
        Edge_point *smaller_point;
        UNTESTED_CODE();
        smaller_point = N_TYPE_REALLOC( out_point, Edge_point, old_total_pts );
        if ( smaller_point != NULL )
        {
            out_point = in_set -> edges -> points = smaller_point;
        }
    }

    if ( out_point != in_point )
    {
        UNTESTED_CODE();
        realign_edges( in_set -> edges, old_num_edges );
    }
    return ERROR;
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                      realloc_edge_set
 *
 * Alter the size of an edge set.
 *
 * All previous edges and edge points remain as before, modulo relocations
 * in memory.  Memory for new
 * edge(s), if any, appear at the end of the edge array and are uninitialized.
 * Similarly for the new point(s).  The num_edges field and total_num_points
 * field are incremented by (respectively) the delta_edges and delta_points
 * arguments.
 *
 * If both edge_set and *edge_set are not equal to NULL, then this routine will
 * not change the value of either pointer -- the double-pointer input is only
 * required when *edge_set equals NULL.
 *
 * Returns:
 *    NO_ERROR on success, and ERROR on failure, with an appropriate error
 *    message being set.  In case of ERROR, we try to return the edge set
 *    unchanged, but that cannot be guaranteed.  There is a rare (untested)
 *    failure case where we free the data structure in addition to returning
 *    ERROR.
 *
 * =============================================================================
 */
static int realloc_edge_set(
    Edge_set** edge_set,
    uint32_t   new_num_edges,
    uint32_t   new_total_pts
)
{
    uint32_t    i, old_num_edges, old_total_pts;
    Edge        *out_edge = NULL;
    Edge_point  *in_point, *out_point;
    Edge_set    *in_set;

    NRE( edge_set );
    in_set = *edge_set;

    /* Trivial case 1:  null pointer in or zero size in. */
    if ( NULL == in_set || 0 == in_set -> num_edges )
    {
        return get_target_edge_set( edge_set, new_num_edges, new_total_pts );
    }
    NRE( in_set -> edges );/*Says he has no edges, but what's he pointing to?*/

    /* Trivial case 2:  zero size out */
    if ( 0 == new_num_edges || 0 == new_total_pts )
    {
        if ( new_num_edges != new_total_pts )
        {
            set_error("Edge_set error:  edges without points or vice versa");
            return ERROR;
        }
        return clear_edge_set( in_set );
    }
    old_num_edges = in_set -> num_edges;
    old_total_pts = in_set -> total_num_pts;
    in_point = in_set -> edges -> points;

    /* If the alteration to points fails, luckily we can immediately give up
     * without having to backtrack.
     */
    NRE(out_point = N_TYPE_REALLOC( in_set -> edges -> points,
                                                Edge_point, new_total_pts ));
    in_set -> edges -> points = out_point;

    if ( NULL == (out_edge = N_TYPE_REALLOC( in_set -> edges, Edge,
                                                            new_num_edges )) )
    {
        /* Backtrack as much as possible (maybe fully) and return ERROR. */
        return handle_edge_realloc_failure(edge_set, in_point, new_total_pts);
    }

    ASSERT( out_edge -> points == out_point );
    in_set -> edges = out_edge; /* Possibly already equal, I don't care. */
    in_set -> num_edges = new_num_edges;
    in_set -> total_num_pts = new_total_pts;

    /* We might want to set the new Edge objects to {0,NULL} but then again,
     * that might just be busywork.  So I have this loop currently disabled.
     */
    for ( i = old_num_edges; FALSE && i < new_num_edges; ++i )
    {
        out_edge[ i ].points = NULL;
        out_edge[ i ].num_points = 0;
    }

    /* If points have moved, fix bad pointers in the edge array. */
    if ( out_point != in_point )
    {
        realign_edges( out_edge, MIN_OF( old_num_edges, new_num_edges ) );
    }

    /* If both have enlarged, we also point 1st new edge to 1st new point. */
    if ( old_num_edges < new_num_edges && old_total_pts < new_total_pts )
    {
        out_edge[ old_num_edges ].points = out_point + old_total_pts;
    }

    return NO_ERROR;
}


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */


/* =============================================================================
 * STATIC                        enlarge_edge_set
 *
 * Enlarge an existing edge set.
 *
 * All previous edges and edge points remain as before, modulo relocations
 * in memory.  Memory for new
 * edge(s), if any, appear at the end of the edge array and are uninitialized.
 * Similarly for the new point(s).  The num_edges field and total_num_points
 * field are incremented by (respectively) the delta_edges and delta_points
 * arguments.
 *
 * It is an error to call this with a null pointer.  It is ok to call
 * this with a zero value in delta_edges or delta_points (or both).
 *
 * Returns:
 *    NO_ERROR on success, and ERROR on failure, with an appropriate error
 *    message being set.
 * =============================================================================
 */
static int enlarge_edge_set(
    Edge_set* edge_set,
    uint32_t  delta_edges,
    uint32_t  delta_points
)
{
    Edge_set *es_copy = edge_set;

    NRE( edge_set );

    ERE( realloc_edge_set( &es_copy, edge_set -> num_edges + delta_edges,
                                edge_set -> total_num_pts + delta_points ) );
    ASSERT( es_copy == edge_set );
    return NO_ERROR;
}


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                      copy_edge_list_into_set
 *
 * Copies a linked list of edge points as an edge into the set of
 * edges.
 *
 * =============================================================================
 */
static int copy_edge_list_into_set(Edge_set* set, Edge_list* list)
{
    uint32_t    num_pts = 0;
    Edge*       last_edge;
    Edge_list*  iter;
    Edge_point* pt;

    NRE( set );
    /* count how long (in pixels) this new edge is. */
    for( iter = list; iter != NULL; iter = iter -> next )
    {
        ++num_pts;
    }

    /* enlarge the edge set by one edge and the right number of points. */
    ERE( enlarge_edge_set( set, 1, num_pts ) );

    /* Write the new edge into the last entry. */
    last_edge = set -> edges + set -> num_edges - 1;
    last_edge -> num_points = num_pts;
    pt = last_edge -> points;
    for( iter = list; iter != NULL; iter = iter -> next )
    {
        *pt++ = *(iter->pt);
    }
    return NO_ERROR;
}


 /*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                         merge_edge_lists
 *
 * Merges two linked lists of edge points into one.
 * At least one of the lists must have an element. The two lists are merged at
 * their heads. So the order of the left list is tail-to-head and the order of
 * the right is head-to-tail.
 * =============================================================================
 */
static Edge_list* merge_edge_lists
(
    Edge_list* left,
    Edge_list* right
)
{
    Edge_list* iter;
    Edge_list* next;
    Edge_list* prev;

    ASSERT(left != NULL || right != NULL);

    if (left == NULL)
    {
        return right;
    }
    else if (right == NULL)
    {
        return left;
    }

    prev = right;
    iter = left;
    while (iter != NULL)
    {
        next = iter->next;
        iter->next = prev;
        prev = iter;
        iter = next;
    }

    return prev;
}



/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                                Gradient
 *
 * This structure is stored to used the Gradient of an image intensity detected
 * using the partial derivative masks. dcol and drow are normalize. Their
 * original mangitude is stored in mag. The field marked is needed by several
 * algorithms in this file
 *
 * =============================================================================
 */
typedef struct
{
    /** @brief Rate of change in brightness along the columns at the point. */
    float dcol;

    /** @brief Rate of change in brightness along the rows at the point. */
    float drow;

    /** @brief Magnitude of the gradient. */
    float mag;

    /** @brief Boolean used for the edge detection algorithm. */
    uint8_t marked;
}
Gradient;

void update_gradient_map_for_noiseless_data(Gradient **map, const Matrix *m, unsigned int padding);


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                     create_gradient_map
 *
 *  Creates a gradient map from a matrix.
 *  It first computes the partial derivatives along x and y.
 *  Then it computes the gradient magnitude and direction for each
 *  pixel, and stores it into map_out
 *
 *  @param map_out Will contain the output gradient information
 *  @param m The input image stored in a matrix
 *  @param sigma the standard deviation of the gaussian used to blur the image
 *  @param use_fourier specifies whether to use Fast Fourier Transform to do
 *         convolution
 *
 * =============================================================================
 */
static int create_gradient_map
(
    Gradient***   map_out,
    const Matrix* m,
    float           sigma,
    unsigned char use_fourier
)
{
    uint32_t num_rows, num_cols;
    uint32_t row, col;
    float    dcol, drow;

    Matrix*    gauss  = NULL;
    Matrix*    m_dcol = NULL;
    Matrix*    m_drow = NULL;
    Gradient** map;
    Gradient*  map_elts;

    num_rows = m->num_rows;
    num_cols = m->num_cols;

    ASSERT(*map_out == NULL);

#ifdef KJB_HAVE_FFTW
    if(use_fourier)
    {
        ERE(get_2D_gaussian_dx_mask(
                    &gauss,
                    num_rows, num_cols,
                    sigma, sigma));

        ASSERT(fourier_convolve_matrix(&m_dcol, m, gauss) == NO_ERROR);

        ERE(get_2D_gaussian_dy_mask(&gauss, num_rows, num_cols, sigma, sigma));
        ASSERT(fourier_convolve_matrix(&m_drow, m, gauss) == NO_ERROR);
    }
    else /* !use_fourier */
#endif
    {
        int mask_size;

        mask_size = ceil(sqrt(2) * 6 * sigma);
        mask_size += 1 - mask_size % 2;

        ASSERT(mask_size % 2 == 1);
        ERE(get_2D_gaussian_dx_mask(&gauss, mask_size, mask_size, sigma, sigma));

        ASSERT(convolve_matrix(&m_dcol, m, gauss) == NO_ERROR);

        ERE(get_2D_gaussian_dy_mask(&gauss, mask_size, mask_size, sigma, sigma));

        ASSERT(convolve_matrix(&m_drow, m, gauss) == NO_ERROR);
    }

    free_matrix(gauss);

    map_elts = N_TYPE_MALLOC( Gradient, num_rows * num_cols );
    ASSERT(map_elts);

    *map_out = N_TYPE_MALLOC( Gradient*, num_rows );
    ASSERT(*map_out);

    map = *map_out;

    for (row = 0; row < num_rows; row++)
    {
        map[ row ] = &(map_elts[ row*num_cols ]);
    }

    for (row = 0; row < num_rows; row++)
    {
        for (col = 0; col < num_cols; col++)
        {
            dcol = m_dcol->elements[ row ][ col ];
            drow = m_drow->elements[ row ][ col ];

            map[ row ][ col ].dcol   = dcol;
            map[ row ][ col ].drow   = drow;
            map[ row ][ col ].mag    = sqrt(dcol*dcol + drow*drow);
            map[ row ][ col ].marked = 0;

            if (map[ row ][ col ].mag >= SMALLEST_DIVISOR)
            {
                map[ row ][ col ].dcol /= map[ row ][ col ].mag;
                map[ row ][ col ].drow /= map[ row ][ col ].mag;
            }
            else
            {
                test_pso("Warning: extremely small gradient of %f at "
                    "(row,col) of (%u,%u)\n", map[ row ][ col ].mag, row, col);
            }
        }
    }

    free_matrix(m_dcol);
    free_matrix(m_drow);

    return NO_ERROR;
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                       follow_gradient
 *
 *  Follow the gradient onto the image along the specified direction
 *
 * =============================================================================
 */
static Gradient* follow_gradient
(
    int32_t*     grad_row_in_out,
    int32_t*     grad_col_in_out,
    float        dir_x,
    float        dir_y,
    Gradient** map,
    uint32_t     num_rows,
    uint32_t     num_cols,
    uint32_t     padding
)
{
    static const int neighbor_positions[ 8 ][ 2 ] = { {  1,  0 },
                                                {  1,  1 },
                                                {  0,  1 },
                                                { -1,  1 },
                                                { -1,  0 },
                                                { -1, -1 },
                                                {  0, -1 },
                                                {  1, -1 } };
    static const float neighbor_vectors[ 8 ][ 2 ] = { {  1, 0 },
                                                {  0.70710678f,  0.70710678f },
                                                {  0,            1 },
                                                { -0.70710678f,  0.70710678f },
                                                { -1,            0 },
                                                { -0.70710678f, -0.70710678f },
                                                {  0,           -1 },
                                                {  0.70710678f, -0.70710678f }};

    uint8_t     i;
    uint8_t     max_neighbor;
    int32_t     grad_col, grad_row;
    float       max_dp;
    float       dp;

    Gradient* grad;

    grad_col = *grad_col_in_out;
    grad_row = *grad_row_in_out;

    max_neighbor = 0;
    max_dp       = -1.0f;
    grad         = &map[ grad_row ][ grad_col ];

    for (i = 0; i < 8; i++)
    {
        dp = dir_x * neighbor_vectors[ i ][ 0 ] +
             dir_y * neighbor_vectors[ i ][ 1 ];

        /* Should have some stochastic tie-breaker here. */
        if (dp >= max_dp)
        {
            max_neighbor = i;
            max_dp       = dp;
        }
    }

    grad_row += neighbor_positions[ max_neighbor ][ 1 ];
    grad_col += neighbor_positions[ max_neighbor ][ 0 ];

    if (grad_row == (int32_t) padding-1)
        grad_row = padding;
    else if (grad_row == (int32_t) (num_rows-padding))
        grad_row = num_rows-padding-1;

    if (grad_col == (int32_t) padding-1)
        grad_col = padding;
    else if (grad_col == (int32_t)(num_cols-padding))
        grad_col = num_cols-padding-1;

    *grad_col_in_out = grad_col;
    *grad_row_in_out = grad_row;

    return &map[ grad_row ][ grad_col ];
}


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                       get_maximal_along_gradient
 *
 *  Performs non maximal suppression along the gradient direction
 *
 * =============================================================================
 */
static Gradient* get_maximal_along_gradient
(
    int32_t*     grad_row_in_out,
    int32_t*     grad_col_in_out,
    Gradient** map,
    uint32_t     num_rows,
    uint32_t     num_cols,
    uint32_t     padding
)
{
    int32_t grad_row, grad_col;
    int32_t curr_grad_row, curr_grad_col;
    int32_t next_grad_row, next_grad_col;
    int32_t prev_grad_row, prev_grad_col;

    Gradient* curr_grad;
    Gradient* next_grad;
    Gradient* prev_grad;
    Gradient* max_grad;

    grad_row = *grad_row_in_out;
    grad_col = *grad_col_in_out;

    curr_grad_row = grad_row;
    curr_grad_col = grad_col;
    curr_grad     = &map[ curr_grad_row ][ curr_grad_col ];

    prev_grad_row = curr_grad_row;
    prev_grad_col = curr_grad_col;
    prev_grad     = follow_gradient(&prev_grad_row, &prev_grad_col,
                                      -(curr_grad->dcol), -(curr_grad->drow),
                                      map, num_rows, num_cols, padding);

    next_grad_row = curr_grad_row;
    next_grad_col = curr_grad_col;
    next_grad     = follow_gradient(&next_grad_row, &next_grad_col,
                                      curr_grad->dcol, curr_grad->drow,
                                      map, num_rows, num_cols, padding);

    max_grad = NULL;
    while (max_grad == NULL)
    {
        if (curr_grad->mag >= next_grad->mag &&
            curr_grad->mag >= prev_grad->mag)
        {
            max_grad = curr_grad;
        }
        else if (curr_grad->mag >= prev_grad->mag)
        {
            curr_grad_row = next_grad_row;
            curr_grad_col = next_grad_col;
            curr_grad     = next_grad;
        }
        else
        {
            curr_grad_row = prev_grad_row;
            curr_grad_col = prev_grad_col;
            curr_grad     = prev_grad;
        }

        prev_grad_row = curr_grad_row;
        prev_grad_col = curr_grad_col;
        prev_grad     = follow_gradient(&prev_grad_row, &prev_grad_col,
                -(curr_grad->dcol), -(curr_grad->drow), map,
                num_rows, num_cols, padding);

        next_grad_row = curr_grad_row;
        next_grad_col = curr_grad_col;
        next_grad     = follow_gradient(&next_grad_row, &next_grad_col,
                                          curr_grad->dcol, curr_grad->drow,
                                          map, num_rows, num_cols, padding);
    }

    *grad_row_in_out = curr_grad_row;
    *grad_col_in_out = curr_grad_col;

    return max_grad;
}


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                       follow_edge_right
 *
 *  Forms an edge by following the gradient using hysteresis (to the right)
 *
 * =============================================================================
 */
static Edge_list* follow_edge_right
(
    float        dir_x,
    float        dir_y,
    int32_t      grad_row,
    int32_t      grad_col,
    Gradient** map,
    uint32_t     num_rows,
    uint32_t     num_cols,
    uint32_t     padding,
    float        thresh
)
{
    Gradient*  grad_curr = NULL;
    Gradient*  grad_next = NULL;
    Edge_list* node = NULL;

    grad_curr = &(map[ grad_row ][ grad_col ]);

    follow_gradient(&grad_row, &grad_col, dir_x, dir_y, map,
            num_rows, num_cols, padding);

    grad_next = get_maximal_along_gradient(&grad_row, &grad_col, map,
            num_rows, num_cols, padding);
    NPETE( grad_next );

    if (!grad_next->marked && grad_next->mag >= thresh &&
        grad_row >= (int32_t) padding && grad_row < (int32_t) (num_rows-padding) &&
        grad_col >= (int32_t) padding && grad_col < (int32_t) (num_cols-padding))
    {
        grad_next->marked = 1;

        NPETE( node = TYPE_MALLOC( Edge_list ) );
        NPETE( node->pt = TYPE_MALLOC( Edge_point ) );

        node->pt->row  = grad_row - padding;
        node->pt->col  = grad_col - padding;
        node->pt->dcol = grad_next->dcol;
        node->pt->drow = grad_next->drow;
        node->pt->mag  = grad_next->mag;

        dir_x =  grad_next->drow;
        dir_y = -grad_next->dcol;

        node->next = follow_edge_right(dir_x, dir_y, grad_row, grad_col, map,
                num_rows, num_cols, padding, thresh);
    }

    return node;
}


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                       follow_edge_left
 *
 *  Forms an edge by following the gradient using hysteresis (to the left)
 *
 * =============================================================================
 */
static Edge_list* follow_edge_left
(
    float        dir_x,
    float        dir_y,
    int32_t      grad_row,
    int32_t      grad_col,
    Gradient** map,
    uint32_t     num_rows,
    uint32_t     num_cols,
    uint32_t     padding,
    float        thresh
)
{
    Gradient*  grad_curr = NULL;
    Gradient*  grad_next = NULL;
    Edge_list* node = NULL;

    grad_curr = &(map[ grad_row ][ grad_col ]);

    follow_gradient(&grad_row, &grad_col, dir_x, dir_y, map,
            num_rows, num_cols, padding);

    grad_next = get_maximal_along_gradient(&grad_row, &grad_col, map,
            num_rows, num_cols, padding);

    if (!grad_next->marked && grad_next->mag >= thresh &&
        grad_row >= (int32_t)padding && grad_row < (int32_t)num_rows-(int32_t)padding &&
        grad_col >= (int32_t)padding && grad_col < (int32_t)num_cols-(int32_t)padding)
    {
        grad_next->marked = 1;

        node = TYPE_MALLOC( Edge_list );
        ASSERT(node);

        node->pt = TYPE_MALLOC( Edge_point );
        ASSERT(node);

        node->pt->row  = grad_row - padding;
        node->pt->col  = grad_col - padding;
        node->pt->dcol = grad_next->dcol;
        node->pt->drow = grad_next->drow;
        node->pt->mag  = grad_next->mag;

        dir_x = -grad_next->drow;
        dir_y =  grad_next->dcol;

        node->next = follow_edge_left(dir_x, dir_y, grad_row, grad_col, map,
                num_rows, num_cols, padding, thresh);
    }

    return node;
}

Edge_set * create_edge_set
(
    unsigned int num_points,
    unsigned int num_edges,
    const Vector * lengths,
    unsigned int num_rows,
    unsigned int num_cols
)
{
    unsigned int i;
    Edge_point*  pt;
    Edge_set*    edge_set = NULL;

    ASSERT(lengths);
    ASSERT( (unsigned int) lengths->length == num_edges);

    ASSERT(NO_ERROR == get_target_edge_set( &edge_set, num_edges, num_points));

    pt = edge_set -> edges -> points;
    edge_set->num_cols = num_cols;
    edge_set->num_rows = num_rows;

    for ( i = 0; i < num_edges; ++i)
    {
        uint32_t edge_length = (uint32_t) lengths -> elements[ i ];
        ASSERT( 0.5 < lengths -> elements[ i ] );
        ASSERT( 0 < edge_length );
        edge_set -> edges[ i ].points = pt;
        edge_set -> edges[ i ].num_points = edge_length;
        pt += edge_length;
    }

    return edge_set;
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                       get_edge_set_from_gradient_map
 *
 *  Finds a sets of edges from a gradient map using the Canny algorithm
 *  http://en.wikipedia.org/wiki/Canny_edge_detector
 *
 * =============================================================================
 */
static Edge_set* get_edge_set_from_gradient_map
(
    Gradient**   map,
    uint32_t       num_rows,
    uint32_t       num_cols,
    uint32_t       padding,
    float          begin_thresh,
    float          end_thresh
)
{
    int32_t  grad_row;
    int32_t  grad_col;
    uint32_t row, col;
    float    dir_x;
    float    dir_y;

    Gradient*   grad;
    Gradient*   max_grad;
    Edge_list*  node;
    Edge_list*  right;
    Edge_list*  left;
    Edge_list*  edge_list;
    Edge_set*   edge_set = NULL;

    ASSERT( NO_ERROR == get_target_edge_set( &edge_set, 0, 0 ) );
    ASSERT(edge_set);

    for (row = padding; row < num_rows-padding; row++)
    {
        for (col = padding; col < num_cols-padding; col++)
        {
            grad = &map[ row ][ col ];

            if (!grad->marked && grad->mag >= begin_thresh)
            {
                grad_row = row;
                grad_col = col;

                max_grad = get_maximal_along_gradient(&grad_row, &grad_col,
                        map, num_rows, num_cols, padding);

                if (!max_grad->marked &&
                    grad_row >= (int32_t)padding && grad_row < (int32_t)num_rows-(int32_t)padding &&
                    grad_col >= (int32_t)padding && grad_col < (int32_t)num_cols-(int32_t)padding)
                {
                    max_grad->marked = 1;

                    node = TYPE_MALLOC( Edge_list );
                    ASSERT(node);
                    node->next = NULL;

                    node->pt = TYPE_MALLOC( Edge_point );
                    ASSERT(node->pt);

                    node->pt->row   = grad_row - padding;
                    node->pt->col   = grad_col - padding;
                    node->pt->dcol  = grad->dcol;
                    node->pt->drow  = grad->drow;
                    node->pt->mag   = grad->mag;

                    dir_x =  max_grad->drow;
                    dir_y = -max_grad->dcol;
                    left  = follow_edge_right(dir_x, dir_y, grad_row,
                            grad_col, map, num_rows, num_cols, padding,
                            end_thresh);

                    dir_x = -max_grad->drow;
                    dir_y =  max_grad->dcol;
                    right = follow_edge_left(dir_x, dir_y, grad_row, grad_col,
                            map, num_rows, num_cols, padding, end_thresh);

                    edge_list = merge_edge_lists(node, right);
                    edge_list = merge_edge_lists(left, edge_list);
                    ASSERT( NO_ERROR==copy_edge_list_into_set(edge_set, edge_list) );
                    free_edge_list(edge_list);
                }
            }
        }
    }

    return edge_set;
}



/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                              detect_image_edge_set
 *
 * Smoothed partial derivative kernels, non-maximal suppression, and hysteresis
 * are used to trace out the edge points from the input image.
 * http://en.wikipedia.org/wiki/Canny_edge_detector
 *
 * @param  r_edges_out    Result parameter. If @em *r_edges_out is NULL, an
 *                        array of edge points is allocated; otherwise its space
 *                        is re-used.
 * @param  g_edges_out    Result parameter. If @em *g_edges_out is NULL, an
 *                        array of edge points is allocated; otherwise its space
 *                        is re-used.
 * @param  b_edges_out    Result parameter. If @em *b_edges_out is NULL, an
 *                        array of edge points is allocated; otherwise its space
 *                        is re-used.
 * @param  img            Image to get the edge points of.
 * @param  sigma          Parameter for the Gaussian kernel used for smoothing
 *                        and edge detection.
 * @param  begin_thresh   Used when scanning the image to look for gradient
 *                        magnitudes to follow under non-maximal suppression.
 * @param  end_thresh     Once an edge is found under non-maximal
 *                        suppression, it is followed (perpendicular to the
 *                        gradient) until the gradient magnitude falls below
 *                        this threshold.
 * @param  padding        Amount of padding to use around the border of the
 *                        image. The padding is created by extending the image.
 * @param fourier         Specifies whether to use fast fourier transform for
 *                        convolutions or not
 * @param noiseless_data  If set to true, it means that there is no noise, so
 *                        every pixel whose intensity is bigger than 0 is an edge
 *                        point. The blurred image is still used to compute the
 *                        gradient, but edge points are detected in the blur free
 *                        image, by labeling as edge points all pixels in the
 *                        image whose intensity is bigger than 0
 *
 * @return On success, NULL is returned. On error, an Error is returned and @em
 * *[rgb]_edges_out are freed and set to NULL.
 * - @link Error_types::ERROR_INV_ARG ERROR_INV_ARG @endlink
 *   Sigma is too small.
 *
 * =============================================================================
 */
int detect_image_edge_set
(
    Edge_set**   edges_out,
    const KJB_image* img,
    float          sigma,
    float          begin_thresh,
    float          end_thresh,
    uint32_t       padding,
    unsigned char  use_fourier,
    unsigned char  noiseless_data
)
{
    Matrix* m = NULL;

    image_to_matrix_2(img, 0.3, 0.59, 0.11, &m);
    ERE(detect_matrix_edge_set(
                edges_out,
                m,
                sigma,
                begin_thresh,
                end_thresh,
                padding,
                use_fourier,
                noiseless_data
            ));

    free_matrix(m);

    return NO_ERROR;
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/**
 * This image is noise free, meaning that every pixel whose intensity
 * is bigger than 0 is an edge point. Therefore we label as edge points all
 * the pixels in the blur free image whose intensity is bigger than 0.
 * The blurred image is still used to compute the
 * gradient, but we set to 0 the gradient for points that are not edge
 * points in the blur free image, so that they will not be considered when
 * linking edge points into edges
 *
 * @param map The gradient map computed from the blurred image
 * @param m   The original image (prior to blurring)
 * @param padding  Amount of padding added around the border of the
 *                 original image when creating the gradient map
 */
void update_gradient_map_for_noiseless_data(
    Gradient **map,
    const Matrix *m,
    unsigned int padding
)
{
    unsigned int i = 0;
    unsigned int j = 0;
    unsigned int num_rows = m->num_rows;
    unsigned int num_cols = m->num_cols;

    for(i = 0; i < num_rows; i++)
    {
        for(j = 0; j < num_cols; j++)
        {
            if(m->elements[i][j] < FLT_EPSILON)
            {
                map[i+padding][j+padding].dcol = 0.0;
                map[i+padding][j+padding].drow = 0.0;
                map[i+padding][j+padding].mag = 0.0;
                map[i+padding][j+padding].marked = 0;
            }
        }
    }
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                              detect_matrix_edge_set
 *
 * Smoothed partial derivative kernels, non-maximal suppression, and hysteresis
 * are used to trace out the edge points from the input image, stored in a
 *  matrix.
 *
 * @param  edges_out     Result parameter. If @em *edges_out is NULL, an array
 *                       of edge points is allocated; otherwise its space is
 *                       re-used.
 * @param  m             Matrix to get the edge points of.
 * @param  sigma         Parameter for the Gaussian kernel used for smoothing
 *                       and edge detection.
 * @param  begin_thresh  Used when scanning the image to look for gradient
 *                       magnitudes to follow under non-maximal suppression.
 * @param  end_thresh    Once an edge is found under non-maximal
 *                       suppression, it is followed (perpendicular to the
 *                       gradient) until the gradient magnitude falls below
 *                       this threshold.
 * @param  padding       Amount of padding to use around the border of the
 *                       matrix. The padding is created by extending the matrix.
 * @param fourier        Specifies whether to use fast fourier transform for
 *                       convolutions or not
 * @param noiseless_data If set to true, it means that there is no noise, so
 *                       every pixel whose intensity is bigger than 0 is an edge
 *                       point. The blurred image is still used to compute the
 *                       gradient, but edge points are detected in the blur free
 *                       image, by labeling as edge points all pixels in the
 *                       image whose intensity is bigger than 0
 *
 *
 * @return On success, NULL is returned. On error, an Error is returned and @em
 * *edges_out are freed and set to NULL.
 * - @link Error_types::ERROR_INV_ARG ERROR_INV_ARG @endlink
 *   Sigma is too small.
 *
 * =============================================================================
 */
int detect_matrix_edge_set
(
    Edge_set**    edges_out,
    const Matrix* m,
    float           sigma,
    float           begin_thresh,
    float           end_thresh,
    uint32_t        padding,
    unsigned char   use_fourier,
    unsigned char   noiseless_data
)
{
    Matrix*    padded_m = NULL;
    Gradient** map = NULL;
    int       e;

    if (*edges_out != NULL)
    {
        free_edge_set(*edges_out);
        *edges_out = NULL;
    }

    ERE(pad_matrix_by_extending(&padded_m, m, padding, padding, padding, padding));

    if ((e =  create_gradient_map(&map, padded_m, sigma, use_fourier)) != NO_ERROR)
    {
        free_matrix(padded_m);
        return e;
    }

    if(noiseless_data)
    {
        update_gradient_map_for_noiseless_data(map, m, padding);
    }

    *edges_out = get_edge_set_from_gradient_map(map, padded_m->num_rows,
            padded_m->num_cols, padding, begin_thresh, end_thresh);

    (*edges_out)->num_rows = m->num_rows;
    (*edges_out)->num_cols = m->num_cols;

    free_matrix(padded_m);
    kjb_free(*map);
    kjb_free(map);

    return NO_ERROR;
}

/*@}*/


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                              free_edge_set
 *
 * Frees the memory allocated to an edge set
 * =============================================================================
 */
void free_edge_set(Edge_set* edge_set)
{
    int rc;

    if (edge_set == NULL)
    {
        return;
    }
    rc = clear_edge_set( edge_set );
    ASSERT( NO_ERROR == rc );
    kjb_free(edge_set);
}

/*@}*/



/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                             remove_short_edges
 *
 * Removes from the edge set edges whose length is less than min_len.
 *
 * Returns:
 *    NO_ERROR on success, and ERROR on failure, with an appropriate error
 *    message being set.  In case of ERROR, the edge set is returned unchanged.
 *
 * @param  edges    Edge set to remove short edges from.
 * @param  min_len  Minimum number of points for an edge. Edges with fewer
 *                  points are removed.
 *
 * =============================================================================
 */
int remove_short_edges(Edge_set* edges, uint32_t min_len)
{
    uint32_t    i, j, num_old_edges;
    Edge_set    new_set;
    Edge_point  *pt;
    Edge        *new_edge, *old_edge;

    NRE( edges );

    /* Trivial case */
    if ( 0 == edges -> num_edges )
    {
        return NO_ERROR;
    }
    NRE( edges -> edges );

    new_set = *edges;
    old_edge = edges -> edges;
    num_old_edges = edges -> num_edges;

    /* Deduce number of edges and edge points in the new edge set. */
    for (i = j = 0; i < edges->num_edges; ++i)
    {
        uint32_t np = edges -> edges[ i ].num_points;
        if ( np <= 0 )
        {
            set_error("Malformed edge set: edge %u has no points", i );
            return ERROR;
        }
        j += np; /* for fun, let's count all the points. */
        if ( np < min_len )
        {
            --new_set.num_edges;
            new_set.total_num_pts -= np;
        }
    }
    ASSERT( edges -> total_num_pts == j ); /* a little dev-mode paranoia. */

    /* Handle corner cases:  removing no edges or removing all the edges. */
    if ( num_old_edges == new_set.num_edges )
    {
        return NO_ERROR;
    }
    if ( 0 == new_set.num_edges )
    {
        ERE( get_target_edge_set( &edges, 0, 0 ) );
        return NO_ERROR;
    }

    /* Allocate memory for new edge set. */
    edges -> edges = NULL;
    if ( get_target_edge_set(&edges, new_set.num_edges, new_set.total_num_pts)
            != NO_ERROR
       )
    {
        edges -> edges = old_edge;
        return ERROR;
    }
    new_edge = edges -> edges;
    pt = new_edge -> points;

    /* Copy long edges into new edge set. */
    for( i = 0; i < num_old_edges; ++i )
    {
        uint32_t np = old_edge[ i ].num_points;
        if ( min_len <= np )
        {
            *new_edge = old_edge[ i ];
            new_edge -> points = pt;
            ++new_edge;

            for( j = 0; j < np; ++j )
            {
                *pt++ = old_edge -> points[ j ];
            }
        }
    }

    kjb_free( old_edge -> points );
    kjb_free( old_edge );
    return NO_ERROR;
}

/*@}*/



/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 * STATIC                 recursively_break_edges_at_corners
 *
 * Recursively breaks apart edges where the gradient direction changes
 * significantly. It does so by finding the edge point with the largest gradient
 * difference on either side, breaks the edge, and recurses on the two newly
 * created edges.
 *
 * @param  edges    Edge set to break apart.
 * @param  i        The index in the edge set to recurse on.
 * @param  thresh   If the dot product of the averaged vectors is less than
 *                  this threshold, the edge is broken.
 * @param  num_avg  Number of gradient vectors to average into one when
 *                  computing the dot product.
 * =============================================================================
 */
static void recursively_break_edges_at_corners
(
    Edge_set* edges,
    uint32_t    i,
    float       thresh,
    uint32_t    num_avg
)
{
    uint32_t j, k;
    uint32_t min_j = 0;

    float  dcol_1, drow_1;
    float  dcol_2, drow_2;
    float  dp;
    float  min_dp;

    ASSERT(num_avg > 0);

    if (edges->edges[ i ].num_points < 2*num_avg)
    {
        return;
    }

    min_dp = thresh;

    for (j = num_avg-1; j < edges->edges[ i ].num_points - num_avg; j++)
    {
        dcol_1 = drow_1 = 0;
        dcol_2 = drow_2 = 0;

        for (k = 0; k < num_avg; k++)
        {
            dcol_1 += edges->edges[ i ].points[ j-k ].dcol;
            drow_1 += edges->edges[ i ].points[ j-k ].drow;
            dcol_2 += edges->edges[ i ].points[ j+k+1 ].dcol;
            drow_2 += edges->edges[ i ].points[ j+k+1 ].drow;
        }

        dcol_1 /= num_avg;
        drow_1 /= num_avg;
        dcol_2 /= num_avg;
        drow_2 /= num_avg;

        dp = fabs(dcol_1*dcol_2 + drow_1*drow_2);
        if (dp < min_dp)
        {
            min_j = j;
            min_dp = dp;
        }
    }

    if (min_dp < thresh)
    {
        ASSERT( NO_ERROR == enlarge_edge_set( edges, 1, 0 ) );

        for (j = edges->num_edges-1; j > i; --j)
        {
            edges -> edges[ j ] = edges -> edges[ j-1 ];
        }

        edges->edges[i].num_points      = min_j+1;
        edges->edges[ i+1 ].num_points -= min_j+1;
        edges->edges[ i+1 ].points     += min_j+1;

        recursively_break_edges_at_corners(edges, i+1, thresh, num_avg);
        recursively_break_edges_at_corners(edges, i, thresh, num_avg);
    }
}


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                          break_edges_at_corners
 *
 * Breaks apart edges where the gradient direction changes
 * significantly. It does so by finding the edge point with the largest gradient
 * difference on either side, breaks the edge, and recurses on the two newly
 * created edges.
 *
 * @param  edges    Edge set to break apart.
 * @param  thresh   If the dot product of the averaged vectors is less than
 *                  this threshold, the edge is broken.
 * @param  num_avg  Number of gradient vectors to average into one when
 *                  computing the dot product.
 *
 * =============================================================================
 */
void break_edges_at_corners(Edge_set* edges, float thresh, uint32_t num_avg)
{
#warning "[Code police] This function does not follow libkjb ERROR convention."
    uint32_t i;

    if(edges == NULL)
    {
        return;
    }

    if (num_avg == 0)
    {
        return;
    }

    for (i = 0; i < edges->num_edges; i++)
    {
        recursively_break_edges_at_corners(edges, i, thresh, num_avg);
    }
}

/*@}*/

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                            sample_edge_set
 *
 * Randomly samples edge points from an array of them.
 *
 * @param  edges_out    Result parameter. If @em *edges_out is NULL, a set
 *                      of edges is allocated; otherwise its space is
 *                      re-used.
 * @param  edges_in     Set of edges to sample from.
 * @param  p            Bernoulli parameter; probability of sampling an edge
 *                      point.
 *
 * @note If @em *edges_out == @em edges_in, then @em edges_in is overwritten.
 *
 * =============================================================================
 */
int sample_edge_set
(
    Edge_set**      edges_out,
    const Edge_set* edges_in,
    float             p
)
{
    uint32_t      e, pt;
    Edge* cur_edge;
    Edge_point* pts;
    Edge_set*   edges = NULL;

    NRE( edges_out );

    if(edges_in == NULL)
    {
        free_edge_set(*edges_out);
        *edges_out = NULL;
        return NO_ERROR;
    }

    if ( 0 == edges_in -> total_num_pts )
    {
        set_error("Cannot sample from an empty edge set");
        return ERROR;
    }

    ERE( get_target_edge_set( &edges,
                        edges_in -> num_edges, edges_in -> total_num_pts ) );
    pts = edges -> edges -> points;
    cur_edge = edges->edges;

    edges -> total_num_pts = 0;
    edges -> num_edges = 0;
    edges -> num_rows = edges_in -> num_rows;
    edges -> num_cols = edges_in -> num_cols;

    /* randomly sample edge points */
    for (e = 0; e < edges_in->num_edges; ++e)
    {
        cur_edge->num_points = 0;

        for (pt = 0; pt < edges_in->edges[e].num_points; ++pt)
        {
            if ( kjb_rand() < p )
            {
                *pts++ = edges_in->edges[ e ].points[ pt ];
                cur_edge->num_points++;
                edges->total_num_pts++;
            }
        }

        /* if any points were sampled from this edge, add it to the set */
        if (cur_edge->num_points != 0)
        {
            cur_edge++;
            edges->num_edges++;
        }
    }

    /* compact unused allocated space */
    ERE(realloc_edge_set(&edges, edges -> num_edges, edges -> total_num_pts));

    if (*edges_out == edges_in)
    {
        /* This makes edges_in point to an invalid memory address. */
        /* TODO: Consider refactoring. */
        free_edge_set(*edges_out);
    }

    *edges_out = edges;

    return NO_ERROR;
}

/*@}*/


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                            color_edge_set
 *
 * Colors all the edges in the edge set with the specified color
 *
 *
 * @param  img_out  Result parameter. If @em *img_out is NULL, an image is
 *                  allocated; otherwise its space is re-used.
 * @param  img_in   Image to color the edge points on.
 * @param  edges    Edge set to use.
 * @param  pxl      Pixel to use for coloring the edge points.
 *
 * @return On success, NULL is returned. On error, an Error is returned and @em
 * *img_out is freed and set to NULL.
 * - Error_types::ERROR_INV_ARG  Edge points indexed outside @em img_in.
 *   The file to read from is not formatted properly.
 *
 * =============================================================================
 */
int color_edge_set
(
    KJB_image**         img_out,
    const KJB_image*    img_in,
    const Edge_set* edges,
    const Pixel*    pxl
)
{
    uint32_t e;

    NRE( edges );

    if (*img_out != img_in)
    {
        kjb_copy_image(img_out, img_in);
    }

    if(img_in == NULL)
    {
        return NO_ERROR;
    }

    for (e = 0; e < edges->num_edges; e++)
    {
        ERE(color_edge_points(img_out, *img_out, edges->edges[ e ].points,
                edges->edges[ e ].num_points, pxl));
    }

    return NO_ERROR;
}

/*@}*/

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                            randomly_color_edge_set
 *
 * Colors each edge in the edge set with a different random color
 *
 * @param  img_out  Result parameter. If @em *img_out is NULL, an image is
 *                  allocated; otherwise its space is re-used.
 * @param  img_in   Image to color the edge points on.
 * @param  edges    Edge set to use.
 *
 * @return On success, NULL is returned. On error, an Error is returned and @em
 * *img_out is freed and set to NULL.
 * - Error_types::ERROR_INV_ARG  Edge points indexed outside @em img_in.
 *   The file to read from is not formatted properly.
 *
 * =============================================================================
 */
int randomly_color_edge_set
(
    KJB_image**         img_out,
    const KJB_image*    img_in,
    const Edge_set* edges
)
{
    uint32_t e;
    int err;

    NRE( edges );

    if (*img_out != img_in)
    {
        kjb_copy_image(img_out, img_in);
    }

    if(edges == NULL)
    {
        return NO_ERROR;
    }

    for (e = 0; e < edges->num_edges; e++)
    {
        if ((err = randomly_color_edge_points(img_out, *img_out,
                        edges->edges[ e ].points, edges->edges[ e ].num_points)))
        {
            return err;
        }
    }

    return NO_ERROR;
}

/*@}*/



/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                            color_edge_set
 *
 * Colors edge points in an image using the input color
 *
 * @param  img_out  Result parameter. If @em *img_out is NULL, an image is
 *                  allocated; otherwise its space is re-used.
 * @param  img_in   Image to color the edge points on.
 * @param  pts      Edge points to use.
 * @param  num_pts  Number of elements in @em pts.
 * @param  pxl      Pixel to use for coloring the edge points.
 *
 * @return On success, NULL is returned. On error, an Error is returned and @em
 * *img_out is freed and set to NULL.
 * - Error_types::ERROR_INV_ARG  Edge points indexed outside @em img_in.
 *   The file to read from is not formatted properly.
 *
 * =============================================================================
 */
int color_edge_points
(
    KJB_image**           img_out,
    const KJB_image*      img_in,
    const Edge_point* pts,
    uint32_t            num_pts,
    const Pixel*      pxl
)
{
    uint32_t pt;
    int row, col;
    KJB_image* img;

    NRE( pts );

    if (*img_out != img_in)
    {
        kjb_copy_image(img_out, img_in);
    }
    img = *img_out;

    for (pt = 0; pt < num_pts; pt++)
    {
        row = pts[ pt ].row;
        col = pts[ pt ].col;

        if (row >= img_in->num_rows || col >= img_in->num_cols)
        {
            if (*img_out != img_in)
            {
                kjb_free_image(*img_out);
                *img_out = 0;
            }

            set_error("%s:%d %s - %s", __FILE__, __LINE__, "color_edge_points", "Edge points outside image to color in");
            return ERROR;
        }

        img->pixels[ row ][ col ] = *pxl;
    }

    return NO_ERROR;
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                            color_edge_set
 *
 * Colors edge points in an image using the input color
 *
 * @param  img_out  Result parameter. If @em *img_out is NULL, an image is
 *                  allocated; otherwise its space is re-used.
 * @param  img_in   Image to color the edge points on.
 * @param  pt       Edge points to draw.
 * @param  pxl      Pixel to use for coloring the edge point.
 *
 * @return On success, NULL is returned. On error, an Error is returned and @em
 * *img_out is freed and set to NULL.
 * - Error_types::ERROR_INV_ARG  Edge points indexed outside @em img_in.
 *   The file to read from is not formatted properly.
 *
 * =============================================================================
 */
int color_edge_point
(
    KJB_image**           img_out,
    const KJB_image*      img_in,
    const Edge_point* pt,
    const Pixel*      pxl
)
{
    int row, col;
    KJB_image* img;

    NRE( pt );
    NRE( pxl );

    if (*img_out != img_in)
    {
        kjb_copy_image(img_out, img_in);
    }
    img = *img_out;

    row = pt->row;
    col = pt->col;

    if (row >= img_in->num_rows || col >= img_in->num_cols)
    {
        if (*img_out != img_in)
        {
            kjb_free_image(*img_out);
            *img_out = 0;
        }

        set_error("%s:%d %s - %s", __FILE__, __LINE__, "color_edge_points", "Edge points outside image to color in");
        return ERROR;
    }

    img->pixels[ row ][ col ] = *pxl;

    return NO_ERROR;
}

/*@}*/

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                         randomly_color_edge_set
 *
 * Randomly colors edge points in an image with a randomly selected color.
 *
 * @param  img_out  Result parameter. If @em *img_out is NULL, an image is
 *                  allocated; otherwise its space is re-used.
 * @param  img_in   Image to color the edge points on.
 * @param  pts      Edge points to use.
 * @param  num_pts  Number of elements in @em pts.
 *
 * @return On success, NULL is returned. On error, an Error is returned and @em
 * *img_out is freed and set to NULL.
 * - Error_types::ERROR_INV_ARG  Edge points indexed outside @em img_in.
 *   The file to read from is not formatted properly.
 *
 * =============================================================================
 */
int randomly_color_edge_points
(
    KJB_image**           img_out,
    const KJB_image*      img_in,
    const Edge_point* pts,
    uint32_t            num_pts
)
{
    Pixel pxl;
    pxl.extra.alpha = 1.0f; /* Not needed; we initialize only for safety. */

    pxl.r = (float)kjb_rand()*KJB_EDGE_MAX_RGB_VALUE;
    pxl.g = (float)kjb_rand()*KJB_EDGE_MAX_RGB_VALUE;
    pxl.b = (float)kjb_rand()*KJB_EDGE_MAX_RGB_VALUE;

    return color_edge_points(img_out, img_in, pts, num_pts, &pxl);
}

/*@}*/


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                             read_edge_set
 *
 * Reads a set of edges in ASCII format from a file.
 * The first line of the file must contains the number of edges, the second has
 * the total number of edge points and the following lines have the number of
 * points in each edge followed by the actual points. For example,
 *
 * @code
 * num_rows=100
 * num_cols=100
 * num_edges=2
 * total_num_points=5
 * num_pts=3
 * col=0 row=0 dcol=1 drow=1 mag=1
 * col=9 row=8 dcol=4 drow=1 mag=1
 * col=1 row=2 dcol=2 drow=1 mag=1
 * num_pts=2
 * col=9 row=8 dcol=4 drow=1 mag=1
 * col=1 row=2 dcol=2 drow=1 mag=1
 * @endcode
 *
 * @param  edges_out  Result parameter. If @em *edges_out is NULL, an edge set
 *                    is allocated; otherwise its space is re-used.
 * @param  fname      Name of the file to read from.
 *
 * @return On success, NULL is returned. On error, an Error is returned and @em
 * *edges_out is freed and set to NULL.
 * - @link Error_types::ERROR_INV_ARG ERROR_INV_ARG @endlink
 *   The file to read from is not formatted properly.
 * - @link Error_types::ERROR_IO ERROR_IO @endlink
 *   Could not read from @em fname.
 *
 * =============================================================================
 */
int read_edge_set
(
    Edge_set** edges_out,
    const char*  fname
)
{
    int err = NO_ERROR;
    char* buffer;
    size_t buffer_size;
    size_t bytes_read = 0;
    FILE* fp = NULL;

    if ((fp = fopen(fname, "r")) == NULL)
    {
            set_error("%s:%d %s - %s",
                    __FILE__,
                    __LINE__,
                    "read_edge_set",
                    strerror(errno));
            return ERROR;
    }

    fseek(fp, 0, SEEK_END);
    buffer_size = ftell(fp);
    rewind(fp);

    buffer = STR_MALLOC( buffer_size + 1 );

    if(buffer == NULL)
    {
        set_error("%s:%d %s",
                __FILE__,
                __LINE__,
                "Memory allocation error.");
        err = ERROR;
        goto cleanup;
    }

    /* read entire file into buffer */
    bytes_read = fread(buffer, 1, buffer_size, fp);
    buffer[buffer_size] = '\0';

    if(ferror(fp))
    {
        kjb_free(buffer);
        set_error("%s:%d %s - %s",
                __FILE__,
                __LINE__,
                "read_edge_set",
                strerror(errno));
        err = ERROR;
        goto cleanup;
    }

    EGC(err = unserialize_edge_set(edges_out, buffer));

cleanup:
    if (fp && fclose(fp) != 0)
    {
        free_edge_set(*edges_out); *edges_out = NULL;
        kjb_free(buffer);

        set_error(
                "%s:%d %s - %s",
                __FILE__,
                __LINE__,
                "read_edge_set",
                strerror(errno));
        err = ERROR;
    }

    kjb_free(buffer);
    return err;
}


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                             unserialize_edge_set
 *
 * @precondition buffer contains the entire serialized edge set
 *
 * =============================================================================
 */
int unserialize_edge_set
(
    Edge_set** edges_out,
    const char* buffer
)
{
    uint32_t i, j;

    Edge_set    *edges, fparams;
    Edge_point* pt;

    char error = 0;

    NRE( edges_out );
    NRE( buffer );

    if(sscanf(buffer, "num_rows=%u\n", & fparams.num_rows ) != 1 )
    {
        error = 1;
        goto finish;
    }

    buffer = strchr(buffer, '\n')  + 1;

    if(sscanf(buffer, "num_cols=%u\n", & fparams.num_cols ) != 1 )
    {
        error = 1;
        goto finish;
    }

    buffer = strchr(buffer, '\n') + 1;

    if(sscanf(buffer, "num_edges=%u\n", & fparams.num_edges ) != 1 )
    {
        error = 1;
        goto finish;
    }

    buffer = strchr(buffer, '\n') + 1;

    if(sscanf(buffer, "total_num_pts=%u\n", & fparams.total_num_pts ) != 1)
    {
        error = 1;
        goto finish;
    }

    buffer = strchr(buffer, '\n') + 1;

    ERE( get_target_edge_set( edges_out,
                                fparams.num_edges, fparams.total_num_pts ) );
    fparams.edges = (*edges_out) -> edges;
    **edges_out = fparams;
    edges = *edges_out;

    pt = edges->edges[0].points;

    for (i = 0; i < edges->num_edges; i++)
    {
        if (sscanf(buffer, "num_pts=%u\n", &(edges->edges[ i ].num_points)) != 1)
        {
            error = 1;
            goto finish;
        }

        buffer = strchr(buffer, '\n') + 1;

        edges->edges[ i ].points = pt;

        for (j = 0; j < edges->edges[ i ].num_points; j++)
        {
            if (sscanf(buffer, "col=%u row=%u dcol=%lf drow=%lf mag=%lf\n",
                        &(pt->col), &(pt->row), &(pt->dcol), &(pt->drow),
                        &(pt->mag)) != 5)
            {
                error = 1;
                goto finish;
            }

            buffer = strchr(buffer, '\n') + 1;

            pt++;
        }
    }

finish:
    if(error)
    {
        set_error(
                "%s:%d %s - %s",
                __FILE__,
                __LINE__,
                "read_edge_points",
                "File not properly formatted to read edge points");
        free_edge_set(*edges_out); *edges_out = NULL;
        return ERROR;
    }

    return NO_ERROR;
}

/*@}*/



/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                            write_edge_set
 *
 * Writes a set of edges in ASCII format to a file.
 * The first line of the file contains the number of edges, the second has the
 * total number of edge points and the following lines have the number of points
 * in each edge followed by the actual points. For example,
 *
 * @code
 * num_rows=100
 * num_cols=100
 * num_edges=2
 * total_num_points=5
 * num_pts=3
 * col=0 row=0 dcol=1 drow=1 mag=1
 * col=9 row=8 dcol=4 drow=1 mag=1
 * col=1 row=2 dcol=2 drow=1 mag=1
 * num_pts=2
 * col=9 row=8 dcol=4 drow=1 mag=1
 * col=1 row=2 dcol=2 drow=1 mag=1
 * @endcode
 *
 * @param  edges  Edge set to write.
 * @param  fname  Name of the file to write to.
 *
 * @return On success, NULL is returned. On error, an Error is returned.
 * - @link Error_types::ERROR_IO ERROR_IO @endlink
 *   Could not read from @em fname.
 *
 * =============================================================================
 */
int write_edge_set
(
    const Edge_set* edges,
    const char*     fname
)
{
    char* buffer = NULL;
    FILE* fp = NULL;

    EGC( serialize_edge_set( edges, &buffer, NULL ) );
    EGC( NULL == (fp = kjb_fopen( fname, "w" )) ? ERROR : NO_ERROR );
    EGC( NULL == buffer ? ERROR : NO_ERROR ); /* harmless paranoia */
    EGC( kjb_fwrite( fp, buffer, strlen( buffer ) + 1 ) );
    EGC( kjb_fclose( fp ) );
    return NO_ERROR;

cleanup:
    add_error("Failure in %s:%d (write_edge_set)", __FILE__, __LINE__ );
    kjb_fclose(fp);
    kjb_free(buffer);
    return ERROR;
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */


/* The following macros will be #undef-ed at end of serialization code.
 * Note: (1) Sometimes, arguments get evaluated more than once.
 *       (2) Some arguments must be lvalues.
 */

#if defined(CUSHION) || defined(LEAKPROOF_REALLOC) || defined(ENSURE_CAPACITY)
#error "macro conflict!" /* a mere warning is not enough, in this case. */
#endif

#define CUSHION 64

/* NB: zero bufsize would not be a problem to standard realloc; it is, here. */
#define LEAKPROOF_REALLOC( buffer, bufsize )                                \
    do                                                                      \
    {                                                                       \
        char* newbuf;                                                       \
        ASSERT( 0 < (bufsize) );                                            \
        if ( NULL == (newbuf = STR_REALLOC((buffer), (bufsize))) )          \
        {                                                                   \
            add_error("%s:%d serialization bad alloc", __FILE__, __LINE__); \
            kjb_free(buffer);                                               \
            return ERROR;                                                   \
        }                                                                   \
        (buffer) = newbuf;                                                  \
    }                                                                       \
    while(0)

#define ENSURE_CAPACITY(buffer, bufsize, need)                              \
    do                                                                      \
    {                                                                       \
        ASSERT( 0 < (bufsize) );                                            \
        while((bufsize) <= (need))                                          \
        {                                                                   \
            (bufsize) *= 2;                                                 \
        }                                                                   \
        LEAKPROOF_REALLOC( buffer, bufsize );                               \
    }                                                                       \
    while(0)

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

static int serialize_edge_array(
    char** buffer_pp,
    size_t* bufsize_p,
    size_t cur_length,
    const Edge* edge_array,
    uint32_t num_edges
)
{
    uint32_t i;
    size_t buffer_size;
    char *buffer;

    NRE( bufsize_p );
    NRE( buffer_pp );
    NRE( *buffer_pp );

    buffer_size = *bufsize_p;
    buffer = *buffer_pp;

    /* Write each Edge and all the Edge_point objects it owns. */
    for (i = 0; i < num_edges; ++i)
    {
        uint32_t j;
        const Edge_point* pt = edge_array[ i ].points;

        NRE( pt );
        ENSURE_CAPACITY(buffer, buffer_size, cur_length + CUSHION);
        cur_length += kjb_sprintf(
                        buffer + cur_length,
                        buffer_size - cur_length,
                        "num_pts=%u\n", edge_array[ i ].num_points
                    );
        ASSERT( cur_length + 1 < buffer_size );

        for (j = 0; j < edge_array[ i ].num_points; ++j, ++pt)
        {
            ENSURE_CAPACITY(buffer, buffer_size, cur_length + 3*CUSHION);

            /* TODO: what about the silhouette field?? */
            cur_length += kjb_sprintf(
                    buffer + cur_length,
                    buffer_size - cur_length,
                    "col=%u row=%u dcol=%f drow=%f mag=%f\n",
                    pt->col, pt->row, pt->dcol, pt->drow, pt->mag
                );
            ASSERT( cur_length + 1 < buffer_size );
        }
    }

    /* shrink buffer to minimum -- big enough for length plus a null byte. */
    LEAKPROOF_REALLOC( buffer, cur_length + 1 );
    *bufsize_p = buffer_size;
    return NO_ERROR;
}


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */


/* =============================================================================
 *                            serialize_edge_set
 *
 * Serializes an edge_set.  out_buffer points to a pointer (contents to be
 * clobbered) that will, at successful completion, indicate the output string
 * in memory that must be released using kjb_free().  If length does not equal
 * NULL, then *length will be set to the output string's length.  You may save
 * an insignificant crumb of execution time by calling with length==NULL.
 * =============================================================================
 */
int serialize_edge_set
(
    const Edge_set* edges,
    char** out_buffer,
    size_t* length
)
{
    size_t buffer_size, cur_length = 0;
    char   *buffer = NULL;

    /* These are ESTIMATES */
    const size_t SET_HEADER_SIZE = 80;
    const size_t EDGE_HEADER_SIZE = 20;
    const size_t POINT_HEADER_SIZE = 80;

    NRE( out_buffer );
    NRE( edges );

    if ( 0 < edges -> num_edges )
    {
        NRE( edges -> edges );
        NRE( edges -> edges -> points );
    }

    /* Initial guess as to buffer size */
    buffer_size = SET_HEADER_SIZE +
        edges->num_edges * EDGE_HEADER_SIZE +
        edges->total_num_pts * POINT_HEADER_SIZE +
        + CUSHION;
    buffer_size = MAX_OF( buffer_size, 1<<14 );

    /* Write fields in Edge_set. */
    ENSURE_CAPACITY(buffer, buffer_size, cur_length + 4 * CUSHION);
    cur_length += kjb_sprintf(
                    buffer + cur_length,
                    buffer_size - cur_length,
                    "num_rows=%u\n"
                        "num_cols=%u\n"
                            "num_edges=%u\n"
                                "total_num_pts=%u\n",
                    edges->num_rows,
                        edges->num_cols,
                            edges->num_edges,
                                edges->total_num_pts
                );
    /* cur_length is like strlen: it does not count terminating null byte. */
    ASSERT( cur_length + 1 < buffer_size );

    ERE( serialize_edge_array( &buffer, &buffer_size, cur_length,
                                        edges -> edges, edges -> num_edges ) );

    /* Finally, now that failure is no longer possible, write the outputs. */
    *out_buffer = buffer;
    if (length) *length = strlen( buffer );

    return NO_ERROR;
}

#undef ENSURE_CAPACITY
#undef LEAKPROOF_REALLOC
#undef CUSHION


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                            copy_edge_set
 *
 * Copies edge_set edges_in into edge_set an edges_out
 * =============================================================================
 */
int copy_edge_set(Edge_set** edges_out, const Edge_set* edges_in)
{
    Edge_set*   out = NULL;
    Edge*       edge_array;
    uint32_t    e, p;

    UNTESTED_CODE();
    NRE( edges_out );

    /* Trivial case */
    if ( NULL == edges_in )
    {
        free_edge_set( *edges_out );
        *edges_out = NULL;
        return NO_ERROR;
    }
    e = edges_in -> num_edges;
    p = edges_in -> total_num_pts;

    /* Allocate the memory we need, and memoize where the big arrays lie. */
    ERE( get_target_edge_set( &out, e, p ) );
    edge_array = out -> edges;

    /* Copy all fields, then unclobber pointer to beginning of edge array. */
    *out = *edges_in;
    out -> edges = edge_array;

    /* Copy input edges and points, if any. */
    if ( 0 < e )
    {
        Edge_point *pt_ptr = out -> edges -> points;

        kjb_memcpy( out -> edges, edges_in -> edges, e*sizeof(Edge) );
        kjb_memcpy( pt_ptr, edges_in -> edges -> points, p*sizeof(Edge_point));

        /* Fix up dangling pointers in edges array. */
        out -> edges -> points = pt_ptr; /* fix first pointer manually */
        realign_edges( out -> edges, e );
    }

    *edges_out = out;
    return NO_ERROR;
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                            remove_edge
 *
 * Removes the edge at index edge_id.  This does not realloc the memory!
 * If you want a realloc too, use realloc_edge_set() or copy_edge_set()
 * afterwards.
 * This is a slow function: expected linear time for random edge_id.
 * =============================================================================
 */
/**
 *  @param edges the edge_set
 *  @param edge_id the index of the edge to remove
 *  @return ERROR if the edge index is out of bounds
 */
int remove_edge(Edge_set* edges, unsigned int edge_id)
{
    uint32_t num_pts_to_remove;

    /* Check preconditions. */
    NRE( edges );
    if(edges->num_edges <= edge_id)
    {
        set_error("Edge ID is out of range");
        return ERROR;
    }
    NRE( edges -> edges );
    if ( 0 == (num_pts_to_remove = edges->edges[ edge_id ].num_points) )
    {
        set_error("Corrupt Edge_set object (an edge without points)");
        return ERROR;
    }

    /* Request is legit, so remove it.  Maybe migrate other edges, points. */
    if ( edge_id < edges -> num_edges - 1 )
    {
        uint32_t i;
        Edge_point *end_pt = edges -> edges -> points + edges -> total_num_pts,
                   *src_pt = edges -> edges[ edge_id + 1 ].points, /* safe! */
                   *dest_pt = src_pt - num_pts_to_remove;

        /* Bubble points leftwards. */
        while( src_pt < end_pt )
        {
            *dest_pt++ = *src_pt++;
        }

        /* Bubble edges leftwards and fix their pointers. */
        for ( i = edge_id + 1; i < edges -> num_edges; ++i )
        {
            edges -> edges[ i-1 ] = edges -> edges[ i ];
            edges -> edges[ i-1 ].points -= num_pts_to_remove;
        }
    }

    edges -> total_num_pts -= num_pts_to_remove;
    edges -> num_edges -= 1;
    return NO_ERROR;
}


/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

/* =============================================================================
 *                            find_edge_index
 *
 * Finds the index where the Edge pointed by iedge is stored in the
 * input edge_set. Notice that this is based on) pointers (the pointer address
 * is compared, not the edge content)
 * =============================================================================
 */
/**
 *  @param edges the edge_set
 *  @param iedge the edge to find
 *  @param index will contain the index where iedge is stored
 *  @return ERROR if the edge is not found in the edge set
 */
int find_edge_index(const Edge_set* edges, const Edge * iedge, unsigned int *index)
{
    unsigned int i = 0;
    if( (index == NULL) || (edges == NULL) )
    {
        return ERROR;
    }
    for( i = 0; i < edges->num_edges ; i++)
    {
        if( (&(edges->edges[i])) == iedge)
        {
            *index = i;
            return NO_ERROR;
        }
    }
    return ERROR;
}


void find_edge_length_from_end_points
(
    double x_0,
    double y_0,
    double x_1,
    double y_1,
    unsigned int * count
)
{
#warning "[Code police] This function does not follow libkjb ERROR convention."

     int steep = 0;
     int y;
     int delta_x, delta_y, error, x;
     int y_step = -1;

     (*count) = 0;

     if(fabs(y_1 - y_0) > fabs(x_1 - x_0))
     {
        steep = 1;
     }
     if(steep)
     {
         double temp = x_0;
         x_0 = y_0;
         y_0 = temp;
         temp = x_1;
         x_1 = y_1;
         y_1 = temp;
     }
     if(x_0 > x_1)
     {
         double temp = x_0;
         x_0 = x_1;
         x_1 = temp;
         temp = y_0;
         y_0 = y_1;
         y_1 = temp;
     }
     delta_x = (int) (x_1 - x_0);
     delta_y = (int) fabs(y_1 - y_0);
     error = delta_x / 2;
     y = y_0;
     if(y_0 < y_1)
     {
         y_step = 1;
     }
     for(x=x_0; x <= x_1; x++)
     {
         (*count)++;
         error -= delta_y;
         if(error < 0)
         {
             y += y_step;
             error += delta_x;
         }
     }
}

void create_edge_from_end_points
(
    double x_0,
    double y_0,
    double x_1,
    double y_1,
    int length,
    Edge_set * edge_set,
    int index
)
{
#warning "[Code police] This function does not follow libkjb conventions."

     int steep = 0;
     int y;
     int delta_x, delta_y, error, x;
     int y_step = -1;
     int count = 0;
     double dcol, drow, mag;
     drow = -(x_1 - x_0);
     dcol = (y_1 - y_0);

     mag = sqrt( (dcol*dcol) + (drow*drow) );
     dcol /= mag;
     drow /= mag;

     if(fabs(y_1 - y_0) > fabs(x_1 - x_0))
     {
        steep = 1;
     }
     if(steep)
     {
         double temp = x_0;
         x_0 = y_0;
         y_0 = temp;
         temp = x_1;
         x_1 = y_1;
         y_1 = temp;
     }
     if(x_0 > x_1)
     {
         double temp = x_0;
         x_0 = x_1;
         x_1 = temp;
         temp = y_0;
         y_0 = y_1;
         y_1 = temp;
     }
     delta_x = (int) (x_1 - x_0);
     delta_y = (int) fabs(y_1 - y_0);
     error = delta_x / 2;
     y = y_0;
     if(y_0 < y_1)
     {
         y_step = 1;
     }
     for(x=x_0; x <= x_1; x++)
     {
         ASSERT( edge_set );
         ASSERT( edge_set -> edges );
         ASSERT( 0 <= index && index < (int) edge_set -> num_edges );
         ASSERT( edge_set -> edges[ index ].points );
         ASSERT( 0 <= count && count < (int)edge_set->edges[index].num_points);

         if(steep)
         {
             if(y < 0 )
             {
                 edge_set->edges[index].points[count].col = 0;
             }
             else if(y >= (int)(edge_set->num_cols) )
             {
                 edge_set->edges[index].points[count].col = edge_set->num_cols -1;
             }
             else
             {
                 edge_set->edges[index].points[count].col = y;
             }
             if(x < 0)
             {
                 edge_set->edges[index].points[count].row = 0;
             }
             else if( x >= (int)(edge_set->num_rows) )
             {
                 edge_set->edges[index].points[count].row = edge_set->num_rows -1;
             }
             else
             {
                 edge_set->edges[index].points[count].row = x;
             }
             edge_set->edges[index].points[count].dcol = dcol;
             edge_set->edges[index].points[count].drow = drow;
             edge_set->edges[index].points[count].mag = 0.0;
             count++;
             /*do y,x*/
         }
         else
         {
             /*do x,y*/
             if(x < 0)
             {
                 edge_set->edges[index].points[count].col = 0;
             }
             else if(x >= (int)(edge_set->num_cols) )
             {
                 edge_set->edges[index].points[count].col = edge_set->num_cols-1;
             }
             else
             {
                 edge_set->edges[index].points[count].col = x;
             }
             if(y < 0)
             {
                 edge_set->edges[index].points[count].row = 0;
             }
             else if(y >= (int)(edge_set->num_rows))
             {
                 edge_set->edges[index].points[count].row = edge_set->num_rows -1;
             }
             else
             {
                 edge_set->edges[index].points[count].row = y;
             }
             edge_set->edges[index].points[count].dcol = dcol;
             edge_set->edges[index].points[count].drow = drow;
             edge_set->edges[index].points[count].mag = 0.0;
             count++;
         }
         error -= delta_y;
         if(error < 0)
         {
             y += y_step;
             error += delta_x;
         }
     }
}

#ifdef __cplusplus
#ifdef COMPILING_CPLUSPLUS_SOURCE
}
#endif
}
#endif
