/**
 * @file
 * @brief Wrapped version of Word_list integrated with kjb_glob
 * @author Andrew Predoehl
 *
 * This file implements a header-only wrapper on Word_list, and integrates it
 * with kjb_glob.
 */

/*
 * $Id: l_word_list.h 17287 2014-08-13 23:56:14Z predoehl $
 */

#ifndef WRAP_KJB_WORD_LIST_H
#define WRAP_KJB_WORD_LIST_H

#include "l/l_sys_io.h"
#include "l/l_word_list.h"
#include "l_cpp/l_exception.h"

#ifdef MAC_OSX
#    include <stddef.h> 
#endif 

#include <vector>
#include <string>
#include <algorithm>
#include <functional>
#include <iterator>

namespace kjb
{

/**
 * @brief Wrapper for the libKJB type Word_list (useful for globs).
 *
 * This class is useful mostly because of the glob-related constructors.  If
 * you don't need globs, then consider using vector<string> instead.
 * This container does not offer any deletion operations, at least currently.
 * But it does at least offer input iterators.
 *
 * @section wliter How to use iterators
 *
 * When you dereference a valid const_iterator generated by this class, the
 * result is like a const char*.  For example, the following shows how to
 * produce a very basic directory listing of regular filenames in the current
 * working directory:
 * @code
 * Word_list wl("*");
 * std::copy(wl.begin(), wl.end(),
 *           std::ostream_iterator<const char*>(std::cout, " "));
 * @endcode
 *
 * @section tilglob Glob
 *
 * A glob(7) is what they call Unix filename pattern-matching expressions, such
 * as "*.cpp" or "/tmp/????.pid" or the like.  We wrap function kjb_c::kjb_glob
 * in some of the ctors for this class -- please see its man page.
 */
class Word_list
{
    kjb_c::Word_list *m_word_list;

    // Basic predicate to match a C++ string to a C string.
    // We need this because we need the test as to whether wl_word equals null.
    //
    // This class wouldn't be necessary -- we could use std::bind2nd -- but in
    // some old versions of GCC it is broken, so we wrote this functor by hand.
    struct pred_matcher
    {
        pred_matcher(const std::string& target) : target_(&target) {}

        bool operator()(const char* wl_word)
        {
            return wl_word && *target_ == wl_word;
        }
    private:
        const std::string* target_;
    };

    // I think we need this for the argc/argv ctor
    static void append_f( Word_list* wl, const char* cstring )
    {
        wl -> append( cstring );
    }

public:

    /**
     * @brief Construct by searching for a @ref tilglob pattern, seeking files.
     *
     * @param [in] pattern  A string containing a filename "glob" pattern
     *
     * @param [in] filter   Optional parameter specifying the kind of directory
     *                      entry wanted:  defaults to kjb_c::is_file, the
     *                      common choice, but also can be kjb_c::is_directory
     *                      or others.
     * @throws kjb::Result_error if the file globbing fails (see note).
     * @throws kjb::KJB_error if memory allocation fails.
     * @see @ref tilglob
     *
     * @note Please see documentation for kjb_c::kjb_glob() for behavior.  The
     * resulting Word_list will indicate, via size(), the number of matches for
     * the glob pattern.  Clearly the number of matches could be zero, which is
     * not regarded as an error.  No matter the size, the resulting word list
     * will lack any "empty" entries.  All entries (if any) will point to a
     * null-terminated string.
     */
    Word_list(
        const char* pattern,
        int (*filter)(const char*) = kjb_c::is_file
    )
    :   m_word_list( 0 )
    {
        int rc = kjb_c::kjb_glob( & m_word_list, pattern, filter );
        if ( rc != kjb_c::NO_ERROR )
        {
            KJB_THROW_2( Result_error, "Bad glob" );
        }
        NTX( m_word_list );
    }

    /**
     * @brief Construct by searching for a @ref tilglob pattern, seeking files.
     *
     * @param [in] pattern  A string containing a filename "glob" pattern
     *
     * @param [in] filter   Optional parameter specifying the kind of directory
     *                      entry wanted:  defaults to kjb_c::is_file, the
     *                      common choice, but also can be kjb_c::is_directory
     *                      or others.
     * Please see the documentation for the other ctor for further discussion.
     */
    Word_list(
        const std::string& pattern,
        int (*filter)(const char*) = kjb_c::is_file
    )
    :   m_word_list( 0 )
    {
        Word_list similar( pattern.c_str(), filter );
        std::swap( m_word_list, similar.m_word_list );
    }

    /**
     * @brief take non-negative word-count; generate that many empty entries.
     * @throws KJB_error if anything (such as memory allocation) fails.
     */
    Word_list( int num_words = 0 )
    :   m_word_list( 0 )
    {
        ETX( kjb_c::get_target_word_list( &m_word_list, num_words ) );
        NTX( m_word_list );
    }

    /// @brief construct a word list from an "argv" style array of arguments.
    Word_list( int argc, const char* const* argv )
    :   m_word_list( 0 )
    {
        ETX( kjb_c::get_target_word_list( &m_word_list, argc ) );
        NTX( m_word_list );
        std::for_each( argv, argv+argc,
                                std::bind1st(std::ptr_fun(append_f),this) );
    }

    /**
     * @brief copy ctor (slow) creates a deep copy of an existing word list.
     * @throws KJB_error if anything (such as memory allocation) fails.
     */
    Word_list( const Word_list& that )
    :   m_word_list( 0 )
    {
        ETX( kjb_c::copy_word_list( &m_word_list, that.m_word_list ) );
        NTX( m_word_list );
    }

    /**
     * @brief assignment operator deep-copies contents of given list.
     * @throws KJB_error if anything (such as memory allocation) fails.
     */
    Word_list& operator=( const Word_list& that )
    {
        if ( this != &that )
        {
            Word_list coppie( that );
            std::swap( m_word_list, coppie.m_word_list );
        }
        return *this;
    }

    /**
     * @brief Number of entries in the word list (could be empty, though).
     *
     * A word list entry might point to a null-terminated string, or it might
     * be empty, i.e., (char*)NULL.  This counts all the entries, empty or not.
     *
     * @note The append operation can alter the size by an unspecified amount.
     */
    size_t size() const
    {
        NTX( m_word_list );
        return m_word_list -> num_words;
    }

    /// @brief return the number of non-empty entries in the list
    int count_strings() const
    {
        return kjb_c::count_strings_in_word_list( m_word_list );
    }

    /**
     * @brief Return the underlying C representation (as const)
     */
    const kjb_c::Word_list* c_ptr() const
    {
        NTX( m_word_list );
        return m_word_list;
    }

    /**
     * @brief Searches the word list for an entry, looking for an exact match.
     * @return If found, returns the index of the entry.  Otherwise, it
     *         returns size().
     * @warning Please test for the not-found possibility!
     * @warning This does NOT follow the same API as kjb_c::search_word_list.
     * @warning This is a linear-time search, i.e., slow.
     */
    size_t match( const std::string& word ) const
    {
        NTX( m_word_list );
        const char* const* const WLW = m_word_list -> words;
        const char* const* const fp = std::find_if(WLW, WLW + size(),
                                                   pred_matcher(word) );
        return fp - WLW;
    }

    /**
     * @brief Access an entry of the word list; this performs range checking.
     *
     * @warning The object can contain empty entries: the result might be NULL.
     */
    const char* operator[]( size_t index ) const
    {
        NTX( m_word_list );
        if ( size() <= index )
        {
            KJB_THROW( Index_out_of_bounds );
        }
        return m_word_list -> words[ index ];
    }

    /**
     * @brief insert a given string into the list (maybe increasing its size).
     *
     * If the list contains empty entries, the given word will go into the
     * first one encountered.  Otherwise the list is reallocated and grown, and
     * the given word goes in the first newly-created entry.
     *
     * @throws KJB_error if anything (such as memory allocation) fails.
     *
     * @warning This operation can alter the size() of the object by an
     *          unspecified amount (not a plus-one increment, in general).
     */
    void append( const std::string& word )
    {
        ETX( kjb_c::append_word_list( &m_word_list, word.c_str() ) );
    }

    /// @brief remove all empty entries from back (only) of the list.
    void trim_empty_entries_at_tail()
    {
        ETX( kjb_c::trim_word_list_empty_entries_at_tail( m_word_list ) );
    }

    /// @brief Convert the word list into a STL vector of STL strings.
    operator std::vector< std::string >() const
    {
        NTX( m_word_list );
        std::vector< std::string > vvv( size() );
        const char* const* const WLW = m_word_list -> words;
        std::copy( WLW, WLW + size(), vvv.begin() );
        return vvv;
    }

    /// @brief concatenate two word lists
    Word_list operator+( const Word_list& that ) const
    {
        Word_list result;
        std::vector< const kjb_c::Word_list* > input( 2 );
        input[ 0 ] = m_word_list;
        input[ 1 ] = that.m_word_list;
        ETX( kjb_c::concat_word_lists(&result.m_word_list, 2, &input.front()));
        return result;
    }

    /// @brief dtor releases memory of underlying C structure
    ~Word_list()
    {
        free_word_list( m_word_list );
    }

    /// @brief iterator class used to traverse and read the list
    //class const_iterator :  public std::iterator< std::input_iterator_tag,
    //                                        void, void, void, const char* >
    class const_iterator :
        public std::iterator<
                    std::bidirectional_iterator_tag,
                    char*,
                    ptrdiff_t,
                    char* const*,
                    char* const&>
    {
        size_t m_index;
        const kjb_c::Word_list* m_list;

    public:
        const_iterator( size_t iii, const kjb_c::Word_list* www )
        :   m_index( iii ), m_list( www )
        {}

        const_iterator& operator++()
        {
            ++m_index;
            return *this;
        }

        const_iterator operator++(int)
        {
            const_iterator tmp(*this);
            operator++();
            return tmp;
        }

        const_iterator& operator--()
        {
            --m_index;
            return *this;
        }

        const_iterator operator--(int)
        {
            const_iterator tmp(*this);
            operator--();
            return tmp;
        }

        reference operator*() const
        {
            return m_list->words[m_index];
        }

        bool operator==(const const_iterator& iii) const
        {
            return m_index == iii.m_index && m_list == iii.m_list;
        }

        bool operator!=(const const_iterator& iii) const
        {
            return m_index != iii.m_index || m_list != iii.m_list;
        }
    };

    /// @brief synonym for cbegin
    const_iterator begin() const
    {
        return cbegin();
    }

    /// @brief synonym for cend
    const_iterator end() const
    {
        return cend();
    }

    /// @brief generate, return const_iterator to front of list
    const_iterator cbegin() const
    {
        return const_iterator( 0, m_word_list );
    }

    /// @brief generate, return const_iterator pointing one-past-last entry
    const_iterator cend() const
    {
        return const_iterator( size(), m_word_list );
    }
};

} // namespace kjb

#endif

