/**
 * @file
 * @brief Code for an alternative wrapper for Pixel supporting HSV color space
 * @author Andrew Predoehl
 */
/*
 * $Id: i_hsv.h 18170 2014-11-10 23:22:06Z ksimek $
 */

#ifndef KJB_I_CPP_HSV_H
#define KJB_I_CPP_HSV_H

#include <i/i_float.h>
#include <i/i_float_io.h>
#include <i_cpp/i_pixel.h>

#include <algorithm> /* for min and max */

namespace kjb 
{

// Forward declaration
class Vector;

/**
 * @addtogroup kjbImageProc
 * @{
 */

/**
 * @brief Alternative Pixel using hue, saturation, value, and opacity (alpha).
 *
 * This is an adaptation of struct kjb_c::Pixel that adapts that type for 
 * an interface based on hue, saturation, and value.
 *
 * Hue is a value from 0 to 1 that cyclically moves through a sort of rainbow
 * of colors.  0 = red, 0.33 = green, 0.67 = blue.
 * In other contexts, hue is often represented as an angle h from 0 to 360 deg.
 * Hue, in this context, then equals h/360.
 *
 * Saturation is a value from 0 to 1 represents the vividness of the color.
 * Saturation = 0 corresponds to achromatic colors:  shades of gray.
 * Saturation = 1 is a very vivid color.
 *
 * Value represents brightness.  Value = 0 is black, and Value = 1 is bright.
 *
 * Alpha represents opacity; 0 is transparent, 1 is opaque.
 * 
 * The formulas used are from the following article:
 * http://en.wikipedia.org/w/index.php?title=HSL_and_HSV&oldid=423114768
 *
 * All the above values range from 0 to 1 in the HSVA interface (including 
 * alpha), and they are
 * transformed to RGBA values ranging from 0 to 255 (including alpha).
 *
 * This struct assumes the user is not interested in the "Invalid Pixel" 
 * structure.
 */
struct PixelHSVA : public kjb_c::Pixel
{
    /**
     * @brief Default ctor, which leaves all fields uninitialized.
     * @warning "Uninitialized" often means "bug-causing" and "troublesome."
     */
    PixelHSVA()
        : kjb_c::Pixel()
    {
    }

    /**
     * @brief This builds a valid pixel from another.
     *
     * Build a pixel from another. It receives a kjb_c::Pixel so as to
     * work with PixelRGBA as well.
     */
    PixelHSVA(const kjb_c::Pixel& p)
    {
        r = p.r;
        g = p.g;
        b = p.b;
        extra.alpha = p.extra.alpha;
    }

    /**
     * @brief This builds a valid pixel with given values for color channels.
     *
     * @param hh    Hue, a value from 0 to 1.  0 = red, .3 = green, .6 = blue.
     * @param ss    Saturation, range 0 to 1.  0 = gray, 1 = very vivid
     * @param vv    Value, range 0 to 1.  0 = black, 1 = bright
     * @param aa    Alpha opacity, 0 to 1.  0 = transparent, 1 = opaque.
     *
     * Once you construct a pixel this way, internally we store r, g, b
     * channels which are related to hh, ss, vv by a messy nonlinear xform.
     */
    PixelHSVA( float hh, float ss, float vv, float aa = 1.0f );


    /// @brief get hue, saturation, value (each in range 0-1 if 0<=r,g,b<=255).
    void get_hsv( float*, float*, float* ) const;


    /// @brief get hue (in range 0-1) but please consider using get_hsv().
    float get_hue() const
    {
        float hue;
        get_hsv( &hue, 0, 0 );
        return hue;
    }

    /// @brief get saturation (in range 0-1) but please consider get_hsv().
    float get_saturation() const
    {
        float saturation;
        get_hsv( 0, &saturation, 0 );
        return saturation;
    }

    /// @brief get value (in range 0-1) but please consider using get_hsv().
    float get_value() const
    {
        float value;
        get_hsv( 0, 0, &value );
        return value;
    }


};



/**
 * @brief Compute the spatial coordinates of a pixel in HSY color space
 *
 * The space I am using here is described in the Wikipedia article linked
 * above.  Please read about the HSL bicone:  a bicone shape is like a top
 * generated by revolving a diamond.  This forms a 3D shape:  picture yourself
 * holding an empty ice cream cone, and on top of that you place an inverted
 * empty ice cream cone.  Lightness L runs along the central axis of rotation:
 * the pointy bottom is black, the top tip is white.
 * Hue H runs around the circumference, basically in a cyclical, rainbow order;
 * 0 degrees is for reddish colors, 180 degrees is for cyanic colors.
 * Saturation describes a point's distance from the central axis; at a radius
 * of 0 the colors are only black, white, and grays.  Farther from the axis the
 * colors grow more vivid.
 *
 * Except that I want to use NTSC 601 for lightness, instead of the more 
 * conventional I=(max{r,g,b}+min{r,g,b})/2.  NTSC 601 defines "luma" Y
 * as an uneven mix of red, green, and blue, 
 * in recognition of the fact that perceptually, green seems
 * brighter than red, and both seem dimmer than blue, for typical computer
 * shades of red, green, and blue.  This distorts the shape from a bicone.
 * The space remains convex.
 *
 * In any case, this function returns the cartesian coordinates (not
 * cylindrical!) of color points within this space, in the form of a vector v.
 * If you think of hue H as an angle from 0 to 359, 
 * then H is basically arctan(v[1] / v[0]).  v[2] is luma;  zero luma is black,
 * unity luma is white.  Components v[0], v[1] are in the closed interval 
 * [-1,1].  Component v[2] is in closed interval [0,1].
 * Not all points in the unit cube of that space are reachable from the RGB
 * cube!
 *
 * This is basically an invertible matrix transformation: vector (r,b,g)' times 
 * matrix [ [1 -.5 -.5]; [0 .866 -.866]; [.3 .59 .11] ] <===(octave notation).
 * The inverse of this matrix is hard-coded into
 * (overloaded) functions PixelRGBA_from_HSLuma_space().
 */
Vector hsluma_space( const kjb_c::Pixel& p );


/**
 * @brief This clampfully transforms a point in HSY space to RGB.
 *
 * @returns A pixel derived from input HSY coordinates, possibly clamped.
 *
 * Please see the comments for
 * get_pixel_from_hsluma_space( const kjb::Vector&, kjb_c::Pixel* ).
 *
 * If the hue-saturation-luma coordinates are outside the HSY polyhedron,
 * this still returns a pixel, but
 * the resulting
 * R,G,B values are clamped to the range 0 to 255.  
 * Alpha (opacity) is set to the default value used by class PixelRGBA.
 */
kjb_c::Pixel get_pixel_from_hsluma_space( const Vector& hsy );


/**
 * @brief This might transform a point in HSY space to RGB.
 *
 * @returns EXIT_SUCCESS iff the values in hsy are valid coordinates inside the
 *          HSY (Y=luma) color polyhedron.  Otherwise, EXIT_FAILURE.
 *
 * Input hsy is a vector of cartesian coordinates where 
 * arctan( hsy[1] / hsy[0] ) is hue, sqrt(hsy[0]**2 + hsy[1]**2) is saturation,
 * and hsy[2] is "luma." 
 * (Luma is a tweak to brightness to compensate for the differences in
 * perceived brightness betwen red, green, and blue.)
 * Valid HSY values are necessarily inside a cuboid with opposite corners 
 * (-1,-1,0) and (1,1,1); but being in this range is not sufficient.
 * The HSY color space is a polyhedron inside that cuboid.
 *
 * Iff input hsy is outside the polyhedron, the return value is EXIT_FAILURE.
 *
 * If the input vector is not within the HSY color polyhedron, then pointer p
 * is not touched.  Otherwise, and if p is not equal to null, the resulting
 * pixel is stored in *p.  If you do not need the pixel, it is safe to pass in
 * a null value, and this function will act like a predicate.
 */
int get_pixel_from_hsluma_space( const Vector& hsy, kjb_c::Pixel* p );


/// @}

} //namespace kjb

#endif
