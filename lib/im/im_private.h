
/* $Id: im_private.h 4727 2009-11-16 20:53:54Z kobus $ */

#ifndef IM_PRIVATE_INCLUDED
#define IM_PRIVATE_INCLUDED

#ifndef __C2MAN__ 


#ifdef __cplusplus
extern "C" {
#endif


/* Kobus. This header file should be considered private */
/*        (The above line is used by fix_incl. Don't remove.)         */
/*        It is shared by im_score.c and im_display.c; the former is a hack */
/*        the later         */


/*
  Define declarations.
*/
#define ColorMatch(color,target,delta) \
  ((((int) ((color).red)-delta) <= (int) ((target).red)) && \
    ((int) ((target).red) <= ((int) ((color).red)+delta)) && \
   (((int) ((color).green)-delta) <= (int) ((target).green)) && \
    ((int) ((target).green) <= ((int) ((color).green)+delta)) && \
   (((int) ((color).red)-delta) <= (int) ((target).red)) && \
    ((int) ((target).red) <= ((int) ((color).red)+delta)))
#define MatteMatch(color,target,delta) \
  (ColorMatch(color,target,delta) && ((color).index == (target).index))
#define MaxColors  Min(windows->image.visual_info->colormap_size,256)
#define MinPanSize  96
#define MaxStacksize  (1 << 15)
#define Push(up,left,right,delta) \
  if ((p < (segment_stack+MaxStacksize)) && (((up)+(delta)) >= 0) && \
      (((up)+(delta)) < image->rows)) \
    { \
      p->y1=(up); \
      p->x1=(left); \
      p->x2=(right); \
      p->y2=(delta); \
      p++; \
    }
#define RoiDelta  8

/*
  State declarations.
*/
#define DefaultState  0x0000
#define EscapeState  0x0001
#define ExitState  0x0002
#define FormerImageState  0x0004
#define ModifierState  0x0008
#define MontageImageState  0x0010
#define NextImageState  0x0020
#define RetainColorsState  0x0040
#define UpdateConfigurationState  0x0080
#define UpdateRegionState  0x0100

/*
  Crop mode declarations.
*/
#define CopyMode  0
#define CropMode  1
#define CutMode  2

/*
  Page size declarations.
*/
static char
  *PageSizes[]=
  {
    "Letter",
    "Tabloid",
    "Ledger",
    "Legal",
    "Statement",
    "Executive",
    "A3",
    "A4",
    "A5",
    "B4",
    "B5",
    "Folio",
    "Quarto",
    "10x14",
    (char *) NULL
  };

/*
  Help widget declarations.
*/
static char
  *ImageAnnotateHelp[]=
  {
    "In annotate mode, the Command widget has these options:",
    "",
    "    Font Name",
    "      fixed",
    "      variable",
    "      5x8",
    "      6x10",
    "      7x13bold",
    "      8x13bold",
    "      9x15bold",
    "      10x20",
    "      12x24",
    "      Browser...",
    "    Font Color",
    "      black",
    "      blue",
    "      cyan",
    "      green",
    "      gray",
    "      red",
    "      magenta",
    "      yellow",
    "      white",
    "      transparent",
    "      Browser...",
    "    Font Color",
    "      black",
    "      blue",
    "      cyan",
    "      green",
    "      gray",
    "      red",
    "      magenta",
    "      yellow",
    "      white",
    "      transparent",
    "      Browser...",
    "    Rotate Text",
    "      45",
    "      90",
    "      135",
    "      180",
    "      225",
    "      270",
    "      315",
    "      Dialog...",
    "    Help",
    "    Dismiss",
    "",
    "Choose a font name from the Font Name sub-menu.  Additional",
    "font names can be specified with the font browser.  You can",
    "change the menu names by setting the X resources font1",
    "through font9.",
    "",
    "Choose a font color from the Font Color sub-menu.",
    "Additional font colors can be specified with the color",
    "browser.  You can change the menu colors by setting the X",
    "resources pen1 through pen9.",
    "",
    "If you select the color browser and press Grab, you can",
    "choose the font color by moving the pointer to the desired",
    "color on the screen and press any button.",
    "",
    "If you choose to rotate the text, choose Rotate Text from the",
    "menu and select an angle.  Typically you will only want to",
    "rotate one line of text at a time.  Depending on the angle you",
    "choose, subsequent lines may end up overwriting each other.",
    "",
    "Choosing a font and its color is optional.  The default font",
    "is fixed and the default color is black.  However, you must",
    "choose a location to begin entering text and press a button.",
    "An underscore character will appear at the location of the",
    "pointer.  The cursor changes to a pencil to indicate you are",
    "in text mode.  To exit immediately, press Dismiss.",
    "",
    "In text mode, any key presses will display the character at",
    "the location of the underscore and advance the underscore",
    "cursor.  Enter your text and once completed press Dismiss to",
    "finish your image annotation.  To correct errors press BACK",
    "SPACE.  To delete an entire line of text, press DELETE.  Any",
    "text that exceeds the boundaries of the image window is",
    "automatically continued onto the next line.",
    "",
    "The actual color you request for the font is saved in the",
    "image.  However, the color that appears in your image window",
    "may be different.  For example, on a monochrome screen the",
    "text will appear black or white even if you choose the color",
    "red as the font color.  However, the image saved to a file",
    "with -write is written with red lettering.  To assure the",
    "correct color text in the final image, any PseudoClass image",
    "is promoted to DirectClass (see miff(5)).  To force a",
    "PseudoClass image to remain PseudoClass, use -colors.",
    (char *) NULL,
  },
  *ImageChopHelp[]=
  {
    "In chop mode, the Command widget has these options:",
    "",
    "    Direction",
    "      horizontal",
    "      vertical",
    "    Help",
    "    Dismiss",
    "",
    "If the you choose the horizontal direction (this is the",
    "default), the area of the image between the two horizontal",
    "endpoints of the chop line is removed.  Otherwise, the area",
    "of the image between the two vertical endpoints of the chop",
    "line is removed.",
    "",
    "Select a location within the image window to begin your chop,",
    "press and hold any button.  Next, move the pointer to",
    "another location in the image.  As you move a line will",
    "connect the initial location and the pointer.  When you",
    "release the button, the area within the image to chop is",
    "determined by which direction you choose from the Command",
    "widget.",
    "",
    "To cancel the image chopping, move the pointer back to the",
    "starting point of the line and release the button.",
    (char *) NULL,
  },
  *ImageColorEditHelp[]=
  {
    "In color edit mode, the Command widget has these options:",
    "",
    "    Pixel Color",
    "      black",
    "      blue",
    "      cyan",
    "      green",
    "      gray",
    "      red",
    "      magenta",
    "      yellow",
    "      white",
    "      Browser...",
    "    Method",
    "      point",
    "      replace",
    "      floodfill",
    "    Delta",
    "      0",
    "      1",
    "      2",
    "      4",
    "      8",
    "      16",
    "      32",
    "      Browser...",
    "    Undo",
    "    Help",
    "    Dismiss",
    "",
    "Choose a pixel color from the Pixel Color sub-menu.",
    "Additional pixel colors can be specified with the color",
    "browser.  You can change the menu colors by setting the X",
    "resources pen1 through pen9.",
    "",
    "Next, choose a color editing method from the Method sub-menu",
    "of the Command widget.  The point method recolors any pixel",
    "selected with the pointer until the button is released.  The",
    "replace method recolors any pixel that matches the color of",
    "the pixel you select with a button press.  Floodfill recolors",
    "any pixel that matches the color of the pixel you select with",
    "a button press and is a neighbor.",
    "",
    "Now press a button to select a pixel within the image window",
    "to change its color.  Additional pixels may be recolored as",
    "prescribed by the method you choose.  You can recolor additional",
    "pixels by increasing the Delta value.  The Delta value is first",
    "added then subtracted from the red, green, and blue of the target",
    "color.  Any pixels within the range is also recolored.",
    "",
    "If the Magnify widget is mapped, it can be helpful in positioning",
    "your pointer within the image (refer to button 2).",
    "",
    "The actual color you request for the pixels is saved in the",
    "image.  However, the color that appears in your image window",
    "may be different.  For example, on a monochrome screen the",
    "pixel will appear black or white even if you choose the",
    "color red as the pixel color.  However, the image saved to a",
    "file with -write is written with red pixels.  To assure the",
    "correct color text in the final image, any PseudoClass image",
    "is promoted to DirectClass (see miff(5)).  To force a",
    "PseudoClass image to remain PseudoClass, use -colors.",
    (char *) NULL,
  },
  *ImageCompositeHelp[]=
  {
    "First a widget window is displayed requesting you to enter an",
    "image name. Press Composite, Grab or type a file name.",
    "Press Cancel if you choose not to create a composite image.",
    "When you choose Grab, move the pointer to the desired window",
    "and press any button.",
    "",
    "A small window appears showing the location of the cursor in",
    "the image window. You are now in composite mode.  To exit",
    "immediately, press Dismiss.  In composite mode, the Command",
    "widget has these options:",
    "",
    "    Operators",
    "      over",
    "      in",
    "      out",
    "      atop",
    "      xor",
    "      plus",
    "      minus",
    "      add",
    "      subtract",
    "      difference",
    "      replace",
    "    Blend",
    "    Help",
    "    Dismiss",
    "",
    "Choose a composite operation from the Operators sub-menu of",
    "the Command widget.  How each operator behaves is described",
    "below.  Image window is the image currently displayed on",
    "your X server and image is the image obtained with the File",
    "Browser widget.",
    "",
    "over     The result is the union of the two image shapes,",
    "         with image obscuring image window in the region of",
    "         overlap.",
    "",
    "in       The result is simply image cut by the shape of",
    "         image window.  None of the image data of image",
    "         window is in the result.",
    "",
    "out      The resulting image is image with the shape of",
    "         image window cut out.",
    "",
    "atop     The result is the same shape as image image window,",
    "         with image obscuring image window where the image",
    "         shapes overlap.  Note this differs from over",
    "         because the portion of image outside image window's",
    "         shape does not appear in the result.",
    "",
    "xor      The result is the image data from both image and",
    "         image window that is outside the overlap region.",
    "         The overlap region is blank.",
    "",
    "plus     The result is just the sum of the image data.",
    "         Output values are cropped to 255 (no overflow).",
    "         This operation is independent of the matte",
    "         channels.",
    "",
    "minus    The result of image - image window, with underflow",
    "         cropped to zero.  The matte channel is ignored (set",
    "         to 255, full coverage).",
    "",
    "add      The result of image + image window, with overflow",
    "         wrapping around (mod 256).",
    "",
    "subtract The result of image - image window, with underflow",
    "         wrapping around (mod 256).  The add and subtract",
    "         operators can be used to perform reversible",
    "         transformations.",
    "",
    "difference",
    "         The result of abs(image - image window).  This is",
    "         useful for comparing two very similar images.",
    "",
    "replace  The resulting image is image window replaced with",
    "         image.  Here the matte information is ignored.",
    "",
    "The image compositor requires a matte, or alpha channel in",
    "the image for some operations.  This extra channel usually",
    "defines a mask which represents a sort of a cookie-cutter",
    "for the image.  This is the case when matte is 255 (full",
    "coverage) for pixels inside the shape, zero outside, and",
    "between zero and 255 on the boundary.  If image does not",
    "have a matte channel, it is initialized with 0 for any pixel",
    "matching in color to pixel location (0,0), otherwise 255.",
    "",
    "If you choose Blend, the composite operator becomes Over.  The",
    "image matte channel percent transparency is initialized to factor.",
    "The image window is initialized to (100-factor). Where factor is the",
    "value you specify in the Dialog widget.",
    "",
    "Note that matte information for image window is not retained",
    "for colormapped X server visuals (e.g. StaticColor,",
    "StaticColor, GrayScale, PseudoColor).  Correct compositing",
    "behavior may require a TrueColor or DirectColor visual or a",
    "Standard Colormap.",
    "",
    "Choosing a composite operator is optional.  The default",
    "operator is replace.  However, you must choose a location to",
    "composite your image and press a button.  Press and hold the",
    "button before releasing and an outline of the image will",
    "appear to help you identify your location.",
    "",
    "The actual colors of the composite image is saved.  However,",
    "the color that appears in image window may be different.",
    "For example, on a monochrome screen image window will appear",
    "black or white even though your composited image may have",
    "many colors.  If the image is saved to a file it is written",
    "with the correct colors.  To assure the correct colors are",
    "saved in the final image, any PseudoClass image is promoted",
    "to DirectClass (see miff(5)).  To force a PseudoClass image",
    "to remain PseudoClass, use -colors.",
    (char *) NULL,
  },
  *ImageCutHelp[]=
  {
    "In cut mode, the Command widget has these options:",
    "",
    "    Help",
    "    Dismiss",
    "",
    "To define a cut region, press button 1 and drag.  The",
    "cut region is defined by a highlighted rectangle that",
    "expands or contracts as it follows the pointer.  Once you",
    "are satisfied with the cut region, release the button.",
    "You are now in rectify mode.  In rectify mode, the Command",
    "widget has these options:",
    "",
    "    Cut",
    "    Help",
    "    Dismiss",
    "",
    "You can make adjustments by moving the pointer to one of the",
    "cut rectangle corners, pressing a button, and dragging.",
    "Finally, press Cut to commit your copy region.  To",
    "exit without cutting the image, press Dismiss.",
    (char *) NULL,
  },
  *ImageCopyHelp[]=
  {
    "In copy mode, the Command widget has these options:",
    "",
    "    Help",
    "    Dismiss",
    "",
    "To define a copy region, press button 1 and drag.  The",
    "copy region is defined by a highlighted rectangle that",
    "expands or contracts as it follows the pointer.  Once you",
    "are satisfied with the copy region, release the button.",
    "You are now in rectify mode.  In rectify mode, the Command",
    "widget has these options:",
    "",
    "    Copy",
    "    Help",
    "    Dismiss",
    "",
    "You can make adjustments by moving the pointer to one of the",
    "copy rectangle corners, pressing a button, and dragging.",
    "Finally, press Copy to commit your copy region.  To",
    "exit without copying the image, press Dismiss.",
    (char *) NULL,
  },
  *ImageCropHelp[]=
  {
    "In crop mode, the Command widget has these options:",
    "",
    "    Help",
    "    Dismiss",
    "",
    "To define a cropping region, press button 1 and drag.  The",
    "cropping region is defined by a highlighted rectangle that",
    "expands or contracts as it follows the pointer.  Once you",
    "are satisfied with the cropping region, release the button.",
    "You are now in rectify mode.  In rectify mode, the Command",
    "widget has these options:",
    "",
    "    Crop",
    "    Help",
    "    Dismiss",
    "",
    "You can make adjustments by moving the pointer to one of the",
    "cropping rectangle corners, pressing a button, and dragging.",
    "Finally, press Crop to commit your cropping region.  To",
    "exit without cropping the image, press Dismiss.",
    (char *) NULL,
  },
  *ImageDrawHelp[]=
  {
    "The cursor changes to a crosshair to indicate you are in",
    "draw mode.  To exit immediately, press Dismiss.  In draw mode,",
    "the Command widget has these options:",
    "",
    "    Primitive",
    "      point",
    "      line",
    "      rectangle",
    "      fill rectangle",
    "      ellipse",
    "      fill ellipse",
    "      polygon",
    "      fill polygon",
    "    Color",
    "      black",
    "      blue",
    "      cyan",
    "      green",
    "      gray",
    "      red",
    "      magenta",
    "      yellow",
    "      white",
    "      transparent",
    "      Browser...",
    "    Stipple",
    "      Brick",
    "      Diagonal",
    "      Scales",
    "      Vertical",
    "      Wavy",
    "      Translucent",
    "      Opaque",
    "      Load...",
    "    Width",
    "      1",
    "      2",
    "      4",
    "      8",
    "      16",
    "      Dialog...",
    "    Undo",
    "    Help",
    "    Dismiss",
    "",
    "Choose a drawing primitive from the Primitive sub-menu.",
    "",
    "Choose a color from the Color sub-menu.  Additional",
    "colors can be specified with the color browser.",
    "",
    "If you choose the color browser and press Grab, you can",
    "select the color by moving the pointer to the desired",
    "color on the screen and press any button.  The transparent",
    "color updates the image matte channel and is useful for",
    "image compositing.",
    "",
    "Choose a stipple, if appropriate, from the Stipple sub-menu.",
    "Additional stipples can be specified with the file browser.",
    "Stipples obtained from the file browser must be on disk in the",
    "X11 bitmap format.",
    "",
    "Choose a width, if appropriate, from the Width sub-menu.  To",
    "choose a specific width select the Dialog widget.",
    "",
    "Choose a point in the Image window and press a button and",
    "hold.  Next, move the pointer to another location in the",
    "image.  As you move, a line connects the initial location and",
    "the pointer.  When you release the button, the image is",
    "updated with the primitive you just drew.  For polygons, the",
    "image is updated when you press and release the button without",
    "moving the pointer.",
    "",
    "To cancel image drawing, move the pointer back to the",
    "starting point of the line and release the button.",
    (char *) NULL,
  },
  *ImageMagickHelp[]=
  {
    "BUTTONS",
    "  The effects of each button press is described below.  Three",
    "  buttons are required.  If you have a two button mouse,",
    "  button 1 and 3 are returned.  Press ALT and button 3 to",
    "  simulate button 2.",
    "",
    "  1    Press this button to map or unmap the Command widget.",
    "",
    "  2    Press and drag to define a region of the image to",
    "       magnify.",
    "",
    "  3    Press and drag to choose from a select set of commands.",
    "       This button behaves differently if the image being",
    "       displayed is a visual image directory.  Here, choose a",
    "       particular tile of the directory and press this button and",
    "       drag to select a command from a pop-up menu.  Choose from",
    "       these menu items:",
    "",
    "           Load",
    "           Next",
    "           Former",
    "           Delete",
    "           Update",
    "",
    "       If you choose Load, the image represented by the tile is",
    "       displayed.  To return to the visual image directory, choose",
    "       Next from the Command widget.  Next and Former moves to the",
    "       next or former image respectively.  Choose Delete to delete",
    "       a particular image tile.  Finally, choose Update to",
    "       synchronize all the image tiles with their respective",
    "       images.",
    "",
    "COMMAND WIDGET",
    "  The Command widget lists a number of sub-menus and commands.",
    "  They are",
    "",
    "      File",
    "        Load...",
    "        Next",
    "        Former",
    "        Select...",
    "        Save...",
    "        Print...",
    "        Delete...",
    "        Canvas...",
    "        Visual Directory...",
    "        Quit",
    "      Edit",
    "        Undo",
    "        Redo",
    "        Cut",
    "        Copy",
    "        Paste",
    "      View",
    "        Half Size",
    "        Original Size",
    "        Double Size",
    "        Resize...",
    "        Apply",
    "        Refresh",
    "        Restore",
    "      Transform",
    "        Crop",
    "        Chop",
    "        Flop",
    "        Flip",
    "        Rotate Right",
    "        Rotate Left",
    "        Rotate...",
    "        Shear...",
    "        Trim Edges",
    "      Enhance",
    "        Brightness...",
    "        Saturation...",
    "        Hue...",
    "        Gamma...",
    "        Sharpen...",
    "        Dull",
    "        Equalize",
    "        Normalize",
    "        Negate",
    "        Grayscale",
    "        Quantize...",
    "      Effects",
    "        Despeckle",
    "        Peak Noise",
    "        Sharpen",
    "        Blur",
    "        Edge Detect",
    "        Emboss",
    "        Spread",
    "        Oil Painting",
    "        Segment",
    "      Image Edit",
    "        Annotate...",
    "        Draw...",
    "        Color...",
    "        Matte...",
    "        Composite...",
    "        Add Border...",
    "        Add Frame...",
    "        Comment...",
    "        Region of Interest...",
    "      Miscellany",
    "        Image Info",
    "        Zoom Image",
    "        Show Histogram",
    "        Background...",
    "        Slide Show",
    "        Preferences...",
    "      Help",
    "        Overview",
    "        Background...",
    "        About Display",
    "",
    "  Menu items with a indented triangle have a sub-menu.  They",
    "  are represented above as the indented items.  To access a",
    "  sub-menu item, move the pointer to the appropriate menu and",
    "  press a button and drag.  When you find the desired sub-menu",
    "  item, release the button and the command is executed.  Move",
    "  the pointer away from the sub-menu if you decide not to",
    "  execute a particular command.",
    "",
    "KEYBOARD ACCELERATORS",
    "  Accelerators are one or two key presses that effect a",
    "  particular command.  The keyboard accelerators that",
    "  display(1) understands is:",
    "",
    "  l    Press to load an image from a file.",
    "",
    "  n    Press to display the next image.",
    "",
    "       If the image is a multi-paged document such as a Postscript",
    "       document, you can skip ahead several pages by preceeding",
    "       this command with a number.  For example to display the",
    "       fourth page beyond the current page, press 4n.",
    "",
    "  f    Press to display the former image.",
    "",
    "       If the image is a multi-paged document such as a Postscript",
    "       document, you can skip behind several pages by preceeding",
    "       this command with a number.  For example to display the",
    "       fourth page preceeding the current page, press 4n.",
    "",
    "  F2   Press to select an image from the command line.",
    "",
    "  s    Press to write the image to a file.",
    "",
    "  p    Press to print the image to a Postscript printer.",
    "",
    "  ^    Press to delete an image file.",
    "",
    "  C    Press to create a blank canvas.",
    "",
    "  q    Press to discard all images and exit program.",
    "",
    "  V    Press to create a Visual Image Directory.",
    "",
    "  u    Press to undo last image transformation.",
    "",
    "  F3   Press to cut a region of the image.",
    "",
    "  F4   Press to copy a region of the image.",
    "",
    "  F5   Press to paste a region to the image.",
    "",
    "  <    Press to half the image size.",
    "",
    "  o    Press to return to the original image size.",
    "",
    "  >    Press to double the image size.",
    "",
    "  %    Press to resize the image to a width and height you",
    "       specify.",
    "",
    "  A    Press to make any image transformations permanent..",
    "",
    "  @    Press to refresh the image window.",
    "",
    "  r    Press to restore the image to its original size.",
    "",
    "  [    Press to crop the image.",
    "",
    "  ]    Press to chop the image.",
    "",
    "  |    Press to flop image in the horizontal direction.",
    "",
    "  -    Press to flip image in the vertical direction.",
    "",
    "  /    Press to rotate the image 90 degrees clockwise.",
    "",
    " \\    Press to rotate the image 90 degrees counter-clockwise.",
    "",
    "  *    Press to rotate the image the number of degrees you",
    "       specify.",
    "",
    "  F6   Press to shear the image the number of degrees you",
    "       specify.",
    "",
    "  t    Press to trim the image edges.",
    "",
    "  F7   Press to vary the color brightness.",
    "",
    "  F8   Press to vary the color saturation.",
    "",
    "  F9   Press to vary the image hue.",
    "",
    "  g    Press to gamma correct the image.",
    "",
    "  F10  Press to sharpen the image contrast.",
    "",
    "  F11  Press to dull the image contrast.",
    "",
    "  =    Press to perform histogram equalization on the image.",
    "",
    "  N    Press to perform histogram normalization on the image.",
    "",
    "  ~    Press to negate the colors of the image.",
    "",
    "  G    Press to convert the image colors to gray.",
    "",
    "  #    Press to set the maximum number of unique colors in the",
    "       image.",
    "",
    "  D    Press to reduce the speckles in an image.",
    "",
    "  P    Press to eliminate peak noise from an image.",
    "",
    "  S    Press to sharpen an image.",
    "",
    "  B    Press to delete an image file.",
    "",
    "  E    Press to detect edges within an image.",
    "",
    "  M    Press to emboss an image.",
    "",
    "  F13  Press to displace pixels by a random amount.",
    "",
    "  O    Press to oil paint an image.",
    "",
    "  Z    Press to segment the image by color.",
    "",
    "  a    Press to annotate the image with text.",
    "",
    "  d    Press to draw on an image.",
    "",
    "  c    Press to edit an image pixel color.",
    "",
    "  m    Press to edit the image matte information.",
    "",
    "  x    Press to composite the image with another.",
    "",
    "  b    Press to add a border to the image.",
    "",
    "  F    Press to add an ornamental border to the image.",
    "",
    "  !    Press to add an image comment.",
    "",
    "  R    Press to apply image processing techniques to a region",
    "       of interest.",
    "",
    "  i    Press to display information about the image.",
    "",
    "  z    Press to map the zoom image window.",
    "",
    "  H    Press to show a histogram of the image.",
    "",
    "  }    display image to background of a window",
    "",
    "  ,    Press to display the next image after pausing.",
    "",
    "  F12  set user preferences",
    "",
    "  h    Press to display helpful information about display(1).",
    "",
    "       Function keys HELP or F1 are synonymous with the h key.",
    "",
    "  Find Press to browse documentation about ImageMagick.",
    "",
    "  v    Press to display the version number of display(1).",
    "",
    "  1-9  Press to change the level of magnification.",
    "",
    "  Use the arrow keys to move the image one pixel up, down,",
    "  left, or right within the magnify window.  Be sure to first",
    "  map the magnify window by pressing button 2.",
    "",
    "  Press ALT and one of the arrow keys to trim off one pixel",
    "  from any side of the image.",
    (char *) NULL,
  },
  *ImageMatteEditHelp[]=
  {
    "Matte information within an image is useful for some",
    "operations such as image compositing (See IMAGE",
    "COMPOSITING).  This extra channel usually defines a mask",
    "which represents a sort of a cookie-cutter for the image.",
    "This is the case when matte is 255 (full coverage) for",
    "pixels inside the shape, zero outside, and between zero and",
    "255 on the boundary.",
    "",
    "A small window appears showing the location of the cursor in",
    "the image window. You are now in matte edit mode.  To exit",
    "immediately, press Dismiss.  In matte edit mode, the Command",
    "widget has these options:",
    "",
    "    Method",
    "      point",
    "      replace",
    "      floodfill",
    "    Delta",
    "      0",
    "      1",
    "      2",
    "      4",
    "      8",
    "      16",
    "      32",
    "      Browser...",
    "    Matte",
    "    Undo",
    "    Help",
    "    Dismiss",
    "",
    "Choose a matte editing method from the Method sub-menu of",
    "the Command widget.  The point method changes the matte value",
    "of any pixel selected with the pointer until the button is",
    "is released.  The replace method changes the matte value of",
    "any pixel that matches the color of the pixel you select with",
    "a button press.  Floodfill changes the matte value of any pixel",
    "that matches the color of the pixel you select with a button",
    "press and is a neighbor.",
    "",
    "Choose Matte Value and a dialog appears requesting a matte",
    "value.  Enter a value between 0 and 255.  This value is",
    "assigned as the matte value of the selected pixel or pixels.",
    "",
    "Now, press any button to select a pixel within the image",
    "window to change its matte value.  You can change the matte",
    "value of additional pixels by increasing the Delta value.  The",
    "Delta value is first added then subtracted from the red, green,",
    "and blue of the target color.  Any pixels within the range also",
    "have their matte value updated.",
    "",
    "If the Magnify widget is mapped, it can be helpful in positioning",
    "your pointer within the image (refer to button 2).",
    "",
    "Matte information is only valid in a DirectClass image.",
    "Therefore, any PseudoClass image is promoted to DirectClass",
    "(see miff(5)).  Note that matte information for PseudoClass",
    "is not retained for colormapped X server visuals (e.g.",
    "StaticColor, StaticColor, GrayScale, PseudoColor) unless you",
    "immediately save your image to a file (refer to Write).",
    "Correct matte editing behavior may require a TrueColor or",
    "DirectColor visual or a Standard Colormap.",
    (char *) NULL,
  },
  *ImagePanHelp[]=
  {
    "When an image exceeds the width or height of the X server",
    "screen, display maps a small panning icon.  The rectangle",
    "within the panning icon shows the area that is currently",
    "displayed in the the image window.  To pan about the image,",
    "press any button and drag the pointer within the panning",
    "icon.  The pan rectangle moves with the pointer and the",
    "image window is updated to reflect the location of the",
    "rectangle within the panning icon.  When you have selected",
    "the area of the image you wish to view, release the button.",
    "",
    "Use the arrow keys to pan the image one pixel up, down,",
    "left, or right within the image window.",
    "",
    "The panning icon is withdrawn if the image becomes smaller",
    "than the dimensions of the X server screen.",
    (char *) NULL,
  },
  *ImagePasteHelp[]=
  {
    "A small window appears showing the location of the cursor in",
    "the image window. You are now in paste mode.  To exit",
    "immediately, press Dismiss.  In paste mode, the Command",
    "widget has these options:",
    "",
    "    Operators",
    "      over",
    "      in",
    "      out",
    "      atop",
    "      xor",
    "      plus",
    "      minus",
    "      add",
    "      subtract",
    "      difference",
    "      replace",
    "    Help",
    "    Dismiss",
    "",
    "Choose a composite operation from the Operators sub-menu of",
    "the Command widget.  How each operator behaves is described",
    "below.  Image window is the image currently displayed on",
    "your X server and image is the image obtained with the File",
    "Browser widget.",
    "",
    "over     The result is the union of the two image shapes,",
    "         with image obscuring image window in the region of",
    "         overlap.",
    "",
    "in       The result is simply image cut by the shape of",
    "         image window.  None of the image data of image",
    "         window is in the result.",
    "",
    "out      The resulting image is image with the shape of",
    "         image window cut out.",
    "",
    "atop     The result is the same shape as image image window,",
    "         with image obscuring image window where the image",
    "         shapes overlap.  Note this differs from over",
    "         because the portion of image outside image window's",
    "         shape does not appear in the result.",
    "",
    "xor      The result is the image data from both image and",
    "         image window that is outside the overlap region.",
    "         The overlap region is blank.",
    "",
    "plus     The result is just the sum of the image data.",
    "         Output values are cropped to 255 (no overflow).",
    "         This operation is independent of the matte",
    "         channels.",
    "",
    "minus    The result of image - image window, with underflow",
    "         cropped to zero.  The matte channel is ignored (set",
    "         to 255, full coverage).",
    "",
    "add      The result of image + image window, with overflow",
    "         wrapping around (mod 256).",
    "",
    "subtract The result of image - image window, with underflow",
    "         wrapping around (mod 256).  The add and subtract",
    "         operators can be used to perform reversible",
    "         transformations.",
    "",
    "difference",
    "         The result of abs(image - image window).  This is",
    "         useful for comparing two very similar images.",
    "",
    "replace  The resulting image is image window replaced with",
    "         image.  Here the matte information is ignored.",
    "",
    "The image compositor requires a matte, or alpha channel in",
    "the image for some operations.  This extra channel usually",
    "defines a mask which represents a sort of a cookie-cutter",
    "for the image.  This is the case when matte is 255 (full",
    "coverage) for pixels inside the shape, zero outside, and",
    "between zero and 255 on the boundary.  If image does not",
    "have a matte channel, it is initialized with 0 for any pixel",
    "matching in color to pixel location (0,0), otherwise 255.",
    "",
    "Note that matte information for image window is not retained",
    "for colormapped X server visuals (e.g. StaticColor,",
    "StaticColor, GrayScale, PseudoColor).  Correct compositing",
    "behavior may require a TrueColor or DirectColor visual or a",
    "Standard Colormap.",
    "",
    "Choosing a composite operator is optional.  The default",
    "operator is replace.  However, you must choose a location to",
    "paste your image and press a button.  Press and hold the",
    "button before releasing and an outline of the image will",
    "appear to help you identify your location.",
    "",
    "The actual colors of the pasted image is saved.  However,",
    "the color that appears in image window may be different.",
    "For example, on a monochrome screen image window will appear",
    "black or white even though your pasted image may have",
    "many colors.  If the image is saved to a file it is written",
    "with the correct colors.  To assure the correct colors are",
    "saved in the final image, any PseudoClass image is promoted",
    "to DirectClass (see miff(5)).  To force a PseudoClass image",
    "to remain PseudoClass, use -colors.",
    (char *) NULL,
  },
  *ImageROIHelp[]=
  {
    "In region of interest mode, the Command widget has these",
    "options:",
    "",
    "    Help",
    "    Dismiss",
    "",
    "To define a region of interest, press button 1 and drag.",
    "The region of interest is defined by a highlighted rectangle",
    "that expands or contracts as it follows the pointer.  Once",
    "you are satisfied with the region of interest, release the",
    "button.  You are now in apply mode.  In apply mode the",
    "Command widget has these options:",
    "",
    "    File",
    "      Image Info",
    "    Edit",
    "      Undo",
    "      Redo",
    "    Transform",
    "      Flop",
    "      Flip",
    "      Rotate Right",
    "      Rotate Left",
    "    Enhance",
    "      Hue...",
    "      Saturation...",
    "      Brightness...",
    "      Gamma...",
    "      Spiff",
    "      Dull",
    "      Equalize",
    "      Normalize",
    "      Negate",
    "      Grayscale",
    "      Quantize...",
    "    Effects",
    "      Despeckle",
    "      Peak Noise",
    "      Sharpen...",
    "      Blur...",
    "      Edge Detect",
    "      Emboss",
    "      Spread",
    "      Oil Painting",
    "      Raise...",
    "      Segment...",
    "    Help",
    "    Dismiss",
    "",
    "You can make adjustments to the region of interest by moving",
    "the pointer to one of the rectangle corners, pressing a",
    "button, and dragging.  Finally, choose an image processing",
    "technique from the Command widget.  You can choose more than",
    "one image processing technique to apply to an area.",
    "Alternatively, you can move the region of interest before",
    "applying another image processing technique.  To exit, press",
    "Dismiss.",
    (char *) NULL,
  },
  *ImageRotateHelp[]=
  {
    "In rotate mode, the Command widget has these options:",
    "",
    "    Pixel Color",
    "      black",
    "      blue",
    "      cyan",
    "      green",
    "      gray",
    "      red",
    "      magenta",
    "      yellow",
    "      white",
    "      Browser...",
    "    Direction",
    "      horizontal",
    "      vertical",
    "    Crop",
    "      false",
    "      true",
    "    Sharpen",
    "      false",
    "      true",
    "    Help",
    "    Dismiss",
    "",
    "Choose a background color from the Pixel Color sub-menu.",
    "Additional background colors can be specified with the color",
    "browser.  You can change the menu colors by setting the X",
    "resources pen1 through pen9.",
    "",
    "If you choose the color browser and press Grab, you can",
    "select the background color by moving the pointer to the",
    "desired color on the screen and press any button.",
    "",
    "Choose a point in the image window and press this button and",
    "hold.  Next, move the pointer to another location in the",
    "image.  As you move a line connects the initial location and",
    "the pointer.  When you release the button, the degree of",
    "image rotation is determined by the slope of the line you",
    "just drew.  The slope is relative to the direction you",
    "choose from the Direction sub-menu of the Command widget.",
    "",
    "To cancel the image rotation, move the pointer back to the",
    "starting point of the line and release the button.",
    (char *) NULL,
  };

/*
  Stipples.
*/
#define BricksWidth  20
#define BricksHeight  20
#define DiagonalWidth  16
#define DiagonalHeight  16
#define HighlightWidth  8
#define HighlightHeight  8
#define ScalesWidth  16
#define ScalesHeight  16
#define ShadowWidth  8
#define ShadowHeight  8
#define VerticalWidth  16
#define VerticalHeight  16
#define WavyWidth  16
#define WavyHeight  16

static unsigned char
  BricksBitmap[] =
  {
    0xff, 0xff, 0x0f, 0x03, 0x0c, 0x00, 0x03, 0x0c, 0x00, 0x03, 0x0c, 0x00,
    0x03, 0x0c, 0x00, 0xff, 0xff, 0x0f, 0x60, 0x80, 0x01, 0x60, 0x80, 0x01,
    0x60, 0x80, 0x01, 0x60, 0x80, 0x01, 0xff, 0xff, 0x0f, 0x03, 0x0c, 0x00,
    0x03, 0x0c, 0x00, 0x03, 0x0c, 0x00, 0x03, 0x0c, 0x00, 0xff, 0xff, 0x0f,
    0x60, 0x80, 0x01, 0x60, 0x80, 0x01, 0x60, 0x80, 0x01, 0x60, 0x80, 0x01
  },
  DiagonalBitmap[] =
  {
    0x44, 0x44, 0x88, 0x88, 0x11, 0x11, 0x22, 0x22, 0x44, 0x44, 0x88, 0x88,
    0x11, 0x11, 0x22, 0x22, 0x44, 0x44, 0x88, 0x88, 0x11, 0x11, 0x22, 0x22,
    0x44, 0x44, 0x88, 0x88, 0x11, 0x11, 0x22, 0x22
  },
  HighlightBitmap[] =
  {
    0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55
  },
  ScalesBitmap[] =
  {
    0x08, 0x08, 0x08, 0x08, 0x14, 0x14, 0xe3, 0xe3, 0x80, 0x80, 0x80, 0x80,
    0x41, 0x41, 0x3e, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x14, 0x14, 0xe3, 0xe3,
    0x80, 0x80, 0x80, 0x80, 0x41, 0x41, 0x3e, 0x3e
  },
  ShadowBitmap[] =
  {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  },
  VerticalBitmap[] =
  {
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
  },
  WavyBitmap[] =
  {
    0xfe, 0xff, 0xfe, 0xff, 0xfe, 0xff, 0xfd, 0xff, 0xfd, 0xff, 0xfb, 0xff,
    0xe7, 0xff, 0x1f, 0xff, 0xff, 0xf8, 0xff, 0xe7, 0xff, 0xdf, 0xff, 0xbf,
    0xff, 0xbf, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f
  };

/*
  Global variable declarations.
*/
static Display
  *display;

static Image
  *copy_image = (Image *) NULL;

static XWindows
  *windows;

/*
  Function prototypes.
*/
static Image
  *XDisplayImage _Declare((Display *,XResourceInfo *,char **,int,Image **,
    unsigned long *)),
  *XLoadImage _Declare((Display *,XResourceInfo *,XWindows *,unsigned int)),
  *XMagickCommand _Declare((Display *,XResourceInfo *,XWindows *,unsigned int,
    KeySym,Image **)),
  *XTileImage _Declare((Display *,XResourceInfo *,XWindows *,Image *,XEvent *)),
  *XVisualDirectoryImage _Declare((Display *,XResourceInfo *,XWindows *));

static int
  XScreenEvent _Declare((Display *,XEvent *,char *));

static unsigned int
  XAnnotateEditImage _Declare((Display *,XResourceInfo *,XWindows *,Image *)),
  XDrawEditImage _Declare((Display *,XResourceInfo *,XWindows *,Image **)),
  XChopImage _Declare((Display *,XResourceInfo *,XWindows *,Image **)),
  XCropImage _Declare((Display *,XResourceInfo *,XWindows *,Image *,
    unsigned int)),
  XBackgroundImage _Declare((Display *,XResourceInfo *,XWindows *,Image **)),
  XColorEditImage _Declare((Display *,XResourceInfo *,XWindows *,Image **)),
  XCompositeImage _Declare((Display *,XResourceInfo *,XWindows *,Image *)),
  XDisplayBackgroundImage _Declare((Display *,XResourceInfo *,Image *)),
  XConfigureImage _Declare((Display *,XResourceInfo *,XWindows *,Image *)),
  XMatteEditImage _Declare((Display *,XResourceInfo *,XWindows *,Image **)),
  XPasteImage _Declare((Display *,XResourceInfo *,XWindows *,Image *)),
  XPrintImage _Declare((Display *,XResourceInfo *,XWindows *,Image **)),
  XRotateImage _Declare((Display *,XResourceInfo *,XWindows *,double,Image **)),
  XROIImage _Declare((Display *,XResourceInfo *,XWindows *,Image **)),
  XSaveImage _Declare((Display *,XResourceInfo *,XWindows *,Image **)),
  XTrimImage _Declare((Display *,XResourceInfo *,XWindows *,Image *));

static void
  ColorFloodfill _Declare((Image *,int,int,XColor,int)),
  MatteFloodfill _Declare((Image *,int,int,int,int)),
  Usage _Declare((unsigned int)),
  XConfigureImageColormap _Declare((Display *,XResourceInfo *,XWindows *,
    Image *)),
  XDrawPanRectangle _Declare((Display *,XWindows *)),
  XMagnifyImage _Declare((Display *,XWindows *,XEvent *)),
  XMakePanImage _Declare((Display *,XResourceInfo *,XWindows *,Image *)),
  XPanImage _Declare((Display *,XWindows *,XEvent *)),
  XMagnifyWindowCommand _Declare((Display *,XWindows *,unsigned int,KeySym)),
  XProgressMonitor _Declare((char *,unsigned int,unsigned int)),
  XSetCropGeometry _Declare((Display *,XWindows *,RectangleInfo *,Image *)),
  XTranslateImage _Declare((Display *,XWindows *,Image *,KeySym)),
  XWarning _Declare((char *,char *));


#ifdef __cplusplus
}
#endif

#endif   /* #ifndef __C2MAN__ */


#endif   /* Include this file. */



