
 
#include "l/l_incl.h" 

#define MAX_NUM_ROWS 200
#define MAX_NUM_COLS 200

#define TEST_BYTE   'K'
#define TEST_INT    44
#define TEST_LONG   -95
#define TEST_FLOAT  123.5f
#define TEST_DOUBLE -789.45
#define TEST_SHORT  89
#define TEST_INT32  -821
#define TEST_INT16  4598

#ifdef SINGLE_PRECISION
#    define TEST_REAL  -78.3f
#else
#    define TEST_REAL  -78.3
#endif 



/* #define VERBOSE 1 */


static void report_failure(const char*);


/* -------------------------------------------------------------------------- */

int main(int  argc, char *argv[] )
{
    unsigned char*    byte_ptr;
    unsigned char**   byte_ptr_ptr;
    short*   short_ptr;
    short**  short_ptr_ptr;
    int*     int_ptr;
    int**    int_ptr_ptr;
    long*    long_ptr;
    long**   long_ptr_ptr;
    kjb_int16*   int16_ptr;
    kjb_int16**  int16_ptr_ptr;
    kjb_int32*   int32_ptr;
    kjb_int32**  int32_ptr_ptr;
    float*   float_ptr;
    float**  float_ptr_ptr;
    double*  double_ptr;
    double** double_ptr_ptr;
    int      i, j;
    int      num_rows, num_cols; 
    int      max_num_rows = MAX_NUM_ROWS;
    int      max_num_cols = MAX_NUM_COLS; 
    int      test_factor = 1; 


    kjb_init(); 

    if (argc > 1)
    {
        EPETE(ss1pi(argv[ 1 ], &test_factor)); 
    }

    if (is_interactive())
    {
        kjb_set_verbose_level(2);
    }
    else 
    {
        kjb_set_verbose_level(0); 
    }

    if (test_factor > 1)
    {
        double d_max_num_rows = (double)max_num_rows * sqrt((double)test_factor);
        double d_max_num_cols = (double)max_num_cols * sqrt((double)test_factor);

        max_num_rows = kjb_rint(d_max_num_rows); 
        max_num_cols = kjb_rint(d_max_num_cols); 
    }

    num_rows = 0;

    while (num_rows < max_num_rows)
    {
        num_cols = 0;

        while (num_cols < max_num_cols)
        {
            verbose_pso(1, "%d X %d\n", num_rows, num_cols); 

            byte_ptr_ptr = allocate_2D_byte_array( num_rows, num_cols );

            if (num_rows > 0)
            {
                byte_ptr = *byte_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                *byte_ptr = TEST_BYTE;
                byte_ptr++;
            }

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    if ( byte_ptr_ptr[ i ][ j] != TEST_BYTE )
                    {
                        report_failure( "2D unsigned char array failure.\n" );
                    }
                }
            }

            free_2D_byte_array(byte_ptr_ptr);

            byte_ptr_ptr = allocate_2D_byte_array(num_rows, num_cols);

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    byte_ptr_ptr[ i ][ j] = TEST_BYTE;
                }
            }

            if (num_rows > 0)
            {
                byte_ptr = *byte_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                if ( *byte_ptr != TEST_BYTE )
                {
                    report_failure( "2D unsigned char array failure.\n" );
                }
                byte_ptr++;
            }
           
            short_ptr_ptr = allocate_2D_short_array( num_rows, num_cols );

            if (num_rows > 0)
            {
                short_ptr = *short_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                *short_ptr = TEST_SHORT;
                short_ptr++;
            }

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    if ( short_ptr_ptr[ i ][ j] != TEST_SHORT )
                    {
                        report_failure( "2D short array failure.\n" );
                    }
                }
            }

            free_2D_short_array( short_ptr_ptr );

            short_ptr_ptr = allocate_2D_short_array(num_rows, num_cols);

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    short_ptr_ptr[ i ][ j] = TEST_SHORT;
                }
            }

            if (num_rows > 0)
            {
                short_ptr = *short_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                if ( *short_ptr != TEST_SHORT )
                {
                    report_failure( "2D short array failure.\n" );
                }
                short_ptr++;
            }

           
            int_ptr_ptr = allocate_2D_int_array( num_rows, num_cols );

            if (num_rows > 0)
            {
                int_ptr = *int_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                *int_ptr = TEST_INT;
                int_ptr++;
            }

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    if ( int_ptr_ptr[ i ][ j] != TEST_INT )
                    {
                        report_failure( "2D int array failure.\n" );
                    }
                }
            }

            free_2D_int_array( int_ptr_ptr );

            int_ptr_ptr = allocate_2D_int_array( num_rows, num_cols );

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    int_ptr_ptr[ i ][ j] = TEST_INT;
                }
            }

            if (num_rows > 0)
            {
                int_ptr = *int_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                if ( *int_ptr != TEST_INT )
                {
                    report_failure( "2D int array failure.\n" );
                }
                int_ptr++;
            }


            long_ptr_ptr = allocate_2D_long_array( num_rows, num_cols );

            if (num_rows > 0)
            {
                long_ptr = *long_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                *long_ptr = TEST_LONG;
                long_ptr++;
            }

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    if ( long_ptr_ptr[ i ][ j] != TEST_LONG )
                    {
                        report_failure( "2D long array failure.\n" );
                    }
                }
            }

            free_2D_long_array( long_ptr_ptr );

            long_ptr_ptr = allocate_2D_long_array( num_rows, num_cols );

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    long_ptr_ptr[ i ][ j] = TEST_LONG;
                }
            }

            if (num_rows > 0)
            {
                long_ptr = *long_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                if ( *long_ptr != TEST_LONG )
                {
                    report_failure( "2D long array failure.\n" );
                }
                long_ptr++;
            }

            int16_ptr_ptr = allocate_2D_int16_array( num_rows, num_cols );

            if (num_rows > 0)
            {
                int16_ptr = *int16_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                *int16_ptr = TEST_INT16;
                int16_ptr++;
            }

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    if ( int16_ptr_ptr[ i ][ j] != TEST_INT16 )
                    {
                        report_failure( "2D kjb_int16 array failure.\n" );
                    }
                }
            }

            free_2D_int16_array( int16_ptr_ptr );

            int16_ptr_ptr = allocate_2D_int16_array( num_rows, num_cols );

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    int16_ptr_ptr[ i ][ j] = TEST_INT16;
                }
            }

            if (num_rows > 0)
            {
                int16_ptr = *int16_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                if ( *int16_ptr != TEST_INT16 )
                {
                    report_failure( "2D kjb_int16 array failure.\n" );
                }
                int16_ptr++;
            }


            int32_ptr_ptr = allocate_2D_int32_array( num_rows, num_cols );

            if (num_rows > 0)
            {
                int32_ptr = *int32_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                *int32_ptr = TEST_INT32;
                int32_ptr++;
            }

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    if ( int32_ptr_ptr[ i ][ j] != TEST_INT32 )
                    {
                        report_failure( "2D kjb_int32 array failure.\n" );
                    }
                }
            }

            free_2D_int32_array( int32_ptr_ptr );

            int32_ptr_ptr = allocate_2D_int32_array( num_rows, num_cols );

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    int32_ptr_ptr[ i ][ j] = TEST_INT32;
                }
            }

            if (num_rows > 0)
            {
                int32_ptr = *int32_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                if ( *int32_ptr != TEST_INT32 )
                {
                    report_failure( "2D kjb_int32 array failure.\n" );
                }
                int32_ptr++;
            }

            float_ptr_ptr = allocate_2D_float_array( num_rows, num_cols );

            if (num_rows > 0)
            {
                float_ptr = *float_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                *float_ptr = TEST_FLOAT;  
                float_ptr++;
            }

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    /*
                    // Dangerous "exact" test, but OK for this purpose.
                    */
                    if ( float_ptr_ptr[ i ][ j] != TEST_FLOAT )
                    {
                        report_failure( "2D float array failure.\n" );
                    }
                }
            }

            free_2D_float_array( float_ptr_ptr );

            float_ptr_ptr = allocate_2D_float_array( num_rows, num_cols );

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    float_ptr_ptr[ i ][ j] = TEST_FLOAT;
                }
            }

            if (num_rows > 0)
            {
                float_ptr = *float_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                /*
                // Dangerous "exact" test, but OK for this purpose.
                */
                if ( *float_ptr != TEST_FLOAT )
                {
                    report_failure( "2D float array failure.\n" );
                }
                float_ptr++;
            }

            double_ptr_ptr = allocate_2D_double_array( num_rows, num_cols );

            if (num_rows > 0)
            {
                double_ptr = *double_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                *double_ptr = TEST_DOUBLE;
                double_ptr++;
            }

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    /*
                    // Dangerous "exact" test, but OK for this purpose.
                    */
                    if ( double_ptr_ptr[ i ][ j] != TEST_DOUBLE )
                    {
                        report_failure( "2D double array failure.\n" );
                    }
                }
            }

            free_2D_double_array( double_ptr_ptr );

            double_ptr_ptr = allocate_2D_double_array( num_rows, num_cols );

            for (i=0; i<num_rows; i++)
            {
                for (j=0; j<num_cols; j++)
                {
                    double_ptr_ptr[ i ][ j] = TEST_DOUBLE;
                }
            }

            if (num_rows > 0)
            {
                double_ptr = *double_ptr_ptr;
            }

            for (i=0; i<num_rows * num_cols; i++)
            {
                /*
                // Dangerous "exact" test, but OK for this purpose.
                */
                if ( *double_ptr != TEST_DOUBLE )
                {
                    report_failure( "2D double array failure.\n" );
                }
                double_ptr++;
            }

            free_2D_double_array( double_ptr_ptr);
            free_2D_float_array(float_ptr_ptr);
            free_2D_int32_array(int32_ptr_ptr);
            free_2D_int16_array(int16_ptr_ptr);
            free_2D_long_array(long_ptr_ptr);
            free_2D_int_array(int_ptr_ptr);
            free_2D_short_array(short_ptr_ptr );
            free_2D_byte_array(byte_ptr_ptr);

            num_cols += kjb_rint(5.0 * kjb_rand()); 
        }
        num_rows += kjb_rint(5.0 * kjb_rand()); 
    }

    return EXIT_SUCCESS; 
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

static void report_failure(const char* message)
{


     p_stderr("\n");
     p_stderr("!!!!!!!!!!!!  FAILURE   !!!!!!!!!!!!\n\n");
     set_high_light(stderr);
     kjb_fputs(stderr, message);
     unset_high_light(stderr);
     p_stderr("\n");
     p_stderr("------------------------------------\n");
     p_stderr("\n");

     kjb_exit( EXIT_FAILURE );
}



 
#include "l/l_incl.h" 

#define MAX_NUM_BLOCKS  50
#define MAX_NUM_ROWS    50
#define MAX_NUM_COLS    50

#define TEST_BYTE   'K'
#define TEST_INT    44
#define TEST_LONG   -95
#define TEST_FLOAT  123.5f
#define TEST_DOUBLE -789.45
#define TEST_SHORT  89
#define TEST_INT32  -821
#define TEST_INT16  4598

#ifdef SINGLE_PRECISION
#    define TEST_REAL  -78.3f
#else
#    define TEST_REAL  -78.3
#endif 


static void report_failure(const char*);

/* -------------------------------------------------------------------------- */

int main(int  argc, char *argv[] )
{
    unsigned char*   byte_ptr;
    unsigned char*** byte_ptr_ptr_ptr;
    short*           short_ptr;
    short***         short_ptr_ptr_ptr;
    int*             int_ptr;
    int***           int_ptr_ptr_ptr;
    long*            long_ptr;
    long***          long_ptr_ptr_ptr;
    kjb_int16*       int16_ptr;
    kjb_int16***     int16_ptr_ptr_ptr;
    kjb_int32*       int32_ptr;
    kjb_int32***     int32_ptr_ptr_ptr;
    float*           float_ptr;
    float***         float_ptr_ptr_ptr;
    double*          double_ptr;
    double***        double_ptr_ptr_ptr;
    int              i, j, k, num_rows, num_cols;
    int              num_blocks;
    int              max_num_rows = MAX_NUM_ROWS;
    int              max_num_cols = MAX_NUM_COLS;
    int              max_num_blocks = MAX_NUM_BLOCKS;
    int              test_factor    = 1;


    kjb_init(); 

    if (argc > 1)
    {
        EPETE(ss1pi(argv[ 1 ], &test_factor)); 
    }

    if (is_interactive())
    {
        kjb_set_verbose_level(2);
    }
    else 
    {
        kjb_set_verbose_level(0); 
    }

    if (test_factor > 1)
    {
        double d_max_num_rows = (double)max_num_rows * pow((double)test_factor, 1.0 / 3.0);
        double d_max_num_cols = (double)max_num_cols * pow((double)test_factor, 1.0 / 3.0);
        double d_max_num_blocks = (double)max_num_blocks * pow((double)test_factor, 1.0 / 3.0);

        max_num_rows = kjb_rint(d_max_num_rows); 
        max_num_cols = kjb_rint(d_max_num_cols); 
        max_num_blocks = kjb_rint(d_max_num_blocks); 
    }

    num_blocks = 0; 

    while (num_blocks < max_num_blocks)
    {
        num_rows = 0;

        while (num_rows < max_num_rows)
        {
            num_cols = 0;

            while (num_cols < max_num_cols)
            {
                verbose_pso(1, "%d X %d X %d\n", num_blocks, num_rows, num_cols); 

                byte_ptr_ptr_ptr = allocate_3D_byte_array( num_blocks, num_rows, num_cols );

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    byte_ptr = **byte_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    *byte_ptr = TEST_BYTE;
                    byte_ptr++;
                }

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            if ( byte_ptr_ptr_ptr[ i ][ j][ k ] != TEST_BYTE )
                            {
                                report_failure( "3D unsigned char array failure.\n" );
                            }
                        }
                    }
                }

                free_3D_byte_array( byte_ptr_ptr_ptr );

                byte_ptr_ptr_ptr = allocate_3D_byte_array( num_blocks, num_rows, num_cols );

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            byte_ptr_ptr_ptr[ i ][ j][ k ] = TEST_BYTE;
                        }
                    }
                } 

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    byte_ptr = **byte_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    if ( *byte_ptr != TEST_BYTE )
                    {
                        report_failure( "3D unsigned char array failure.\n" );
                    }
                    byte_ptr++;
                }



               
                short_ptr_ptr_ptr = allocate_3D_short_array( num_blocks, num_rows, num_cols );

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    short_ptr = **short_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    *short_ptr = TEST_SHORT;
                    short_ptr++;
                }

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            if ( short_ptr_ptr_ptr[ i ][ j][ k ] != TEST_SHORT )
                            {
                                report_failure( "3D short array failure.\n" );
                            }
                        }
                    }
                }

                free_3D_short_array( short_ptr_ptr_ptr );

                short_ptr_ptr_ptr = allocate_3D_short_array( num_blocks, num_rows, num_cols );

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            short_ptr_ptr_ptr[ i ][ j][ k ] = TEST_SHORT;
                        }
                    }
                } 

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    short_ptr = **short_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    if ( *short_ptr != TEST_SHORT )
                    {
                        report_failure( "3D short array failure.\n" );
                    }
                    short_ptr++;
                }

               
                int_ptr_ptr_ptr = allocate_3D_int_array( num_blocks, num_rows, num_cols );

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    int_ptr = **int_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    *int_ptr = TEST_INT;
                    int_ptr++;
                }

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            if ( int_ptr_ptr_ptr[ i ][ j][ k ] != TEST_INT )
                            {
                                report_failure( "3D int array failure.\n" );
                            }
                        }
                    }
                }

                free_3D_int_array( int_ptr_ptr_ptr );

                int_ptr_ptr_ptr = allocate_3D_int_array( num_blocks, num_rows, num_cols );

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            int_ptr_ptr_ptr[ i ][ j][ k ] = TEST_INT;
                        }
                    }
                } 

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    int_ptr = **int_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    if ( *int_ptr != TEST_INT )
                    {
                        report_failure( "3D int array failure.\n" );
                    }
                    int_ptr++;
                }



               
                long_ptr_ptr_ptr = allocate_3D_long_array( num_blocks, num_rows, num_cols );

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    long_ptr = **long_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    *long_ptr = TEST_LONG;
                    long_ptr++;
                }

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            if ( long_ptr_ptr_ptr[ i ][ j][ k ] != TEST_LONG )
                            {
                                report_failure( "3D long array failure.\n" );
                            }
                        }
                    }
                }

                free_3D_long_array( long_ptr_ptr_ptr );

                long_ptr_ptr_ptr = allocate_3D_long_array( num_blocks, num_rows, num_cols );

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            long_ptr_ptr_ptr[ i ][ j][ k ] = TEST_LONG;
                        }
                    }
                } 

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    long_ptr = **long_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    if ( *long_ptr != TEST_LONG )
                    {
                        report_failure( "3D long array failure.\n" );
                    }
                    long_ptr++;
                }



               
                int16_ptr_ptr_ptr = allocate_3D_int16_array( num_blocks, num_rows, num_cols );

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    int16_ptr = **int16_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    *int16_ptr = TEST_INT16;
                    int16_ptr++;
                }

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            if ( int16_ptr_ptr_ptr[ i ][ j][ k ] != TEST_INT16 )
                            {
                                report_failure( "3D kjb_int16 array failure.\n" );
                            }
                        }
                    }
                }

                free_3D_int16_array( int16_ptr_ptr_ptr );

                int16_ptr_ptr_ptr = allocate_3D_int16_array( num_blocks, num_rows, num_cols );

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            int16_ptr_ptr_ptr[ i ][ j][ k ] = TEST_INT16;
                        }
                    }
                } 

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    int16_ptr = **int16_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    if ( *int16_ptr != TEST_INT16 )
                    {
                        report_failure( "3D kjb_int16 array failure.\n" );
                    }
                    int16_ptr++;
                }




               
                int32_ptr_ptr_ptr = allocate_3D_int32_array( num_blocks, num_rows, num_cols );

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    int32_ptr = **int32_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    *int32_ptr = TEST_INT32;
                    int32_ptr++;
                }

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            if ( int32_ptr_ptr_ptr[ i ][ j][ k ] != TEST_INT32 )
                            {
                                report_failure( "3D kjb_int32 array failure.\n" );
                            }
                        }
                    }
                }

                free_3D_int32_array( int32_ptr_ptr_ptr );

                int32_ptr_ptr_ptr = allocate_3D_int32_array( num_blocks, num_rows, num_cols );

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            int32_ptr_ptr_ptr[ i ][ j][ k ] = TEST_INT32;
                        }
                    }
                } 

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    int32_ptr = **int32_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    if ( *int32_ptr != TEST_INT32 )
                    {
                        report_failure( "3D kjb_int32 array failure.\n" );
                    }
                    int32_ptr++;
                }



               
               

               
                float_ptr_ptr_ptr = allocate_3D_float_array( num_blocks, num_rows, num_cols );

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    float_ptr = **float_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    *float_ptr = TEST_FLOAT;
                    float_ptr++;
                }

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            /*
                            // Dangerous "exact" test, but OK for this purpose.
                            */
                            if ( float_ptr_ptr_ptr[ i ][ j][ k ] != TEST_FLOAT )
                            {
                                report_failure( "3D float array failure.\n" );
                            }
                        }
                    }
                }

                free_3D_float_array( float_ptr_ptr_ptr );

                float_ptr_ptr_ptr = allocate_3D_float_array( num_blocks, num_rows, num_cols );

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            float_ptr_ptr_ptr[ i ][ j][ k ] = TEST_FLOAT;
                        }
                    }
                } 

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    float_ptr = **float_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    /*
                    // Dangerous "exact" test, but OK for this purpose.
                    */
                    if ( *float_ptr != TEST_FLOAT )
                    {
                        report_failure( "3D float array failure.\n" );
                    }
                    float_ptr++;
                }



                double_ptr_ptr_ptr = allocate_3D_double_array( num_blocks, num_rows, 
                                                              num_cols );

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    double_ptr = **double_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    *double_ptr = TEST_DOUBLE;
                    double_ptr++;
                }

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            /*
                            // Dangerous "exact" test, but OK for this purpose.
                            */
                            if ( double_ptr_ptr_ptr[ i ][ j][ k ] != TEST_DOUBLE )
                            {
                                report_failure( "3D double array failure.\n" );
                            }
                        }
                    }
                }

                free_3D_double_array( double_ptr_ptr_ptr );

                double_ptr_ptr_ptr = allocate_3D_double_array( num_blocks, num_rows, 
                                                               num_cols );

                for (i=0; i<num_blocks; i++) 
                {
                    for (j=0; j<num_rows; j++)
                    {
                        for (k=0; k<num_cols; k++)
                        {
                            double_ptr_ptr_ptr[ i ][ j][ k ] = TEST_DOUBLE;
                        }
                    }
                } 

                if ((num_blocks > 0) && (num_rows > 0))
                {
                    double_ptr = **double_ptr_ptr_ptr;
                }

                for (i=0; i<num_blocks * num_rows * num_cols; i++)
                {
                    /*
                    // Dangerous "exact" test, but OK for this purpose.
                    */
                    if ( *double_ptr != TEST_DOUBLE )
                    {
                        report_failure( "3D double array failure.\n" );
                    }
                    double_ptr++;
                }

               
                free_3D_double_array(double_ptr_ptr_ptr);
                free_3D_float_array(float_ptr_ptr_ptr);
                free_3D_int32_array(int32_ptr_ptr_ptr);
                free_3D_int16_array(int16_ptr_ptr_ptr);
                free_3D_long_array(long_ptr_ptr_ptr);
                free_3D_int_array(int_ptr_ptr_ptr);
                free_3D_short_array(short_ptr_ptr_ptr);
                free_3D_byte_array(byte_ptr_ptr_ptr);

                num_cols += kjb_rint(5.0 * kjb_rand()); 
            }

            num_rows += kjb_rint(5.0 * kjb_rand()); 
        }

        num_blocks += kjb_rint(5.0 * kjb_rand()); 
    }


    return EXIT_SUCCESS; 
}

/*  /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\   */

static void report_failure(const char* message)
{


     p_stderr("\n");
     p_stderr("!!!!!!!!!!!!  FAILURE   !!!!!!!!!!!!\n\n");
     set_high_light(stderr);
     kjb_fputs(stderr, message);
     unset_high_light(stderr);
     p_stderr("\n");
     p_stderr("------------------------------------\n");
     p_stderr("\n");

     kjb_exit( EXIT_FAILURE );
}



#include "m/m_incl.h" 

#define MAX_NUM_ROWS   1000
#define MAX_NUM_COLS   1000
#define BASE_NUM_TRIES 500

/*ARGSUSED*/
int main(int argc, char **argv)
{
    Matrix* source_mp = NULL;
    Int_matrix* mp = NULL;
    Int_matrix* mp2 = NULL;
    int i;
    long memcpy_cpu = 0;
    long std_cpy_cpu   = 0; 
    int  num_tries = BASE_NUM_TRIES;
    int  test_factor = 1;


    kjb_init(); 

    if (argc > 1)
    {
        EPETE(ss1pi(argv[ 1 ], &test_factor)); 
    }

    if (test_factor <= 0)
    {
        num_tries = 1;
    }
    else
    {
        num_tries *= test_factor;
    } 

    kjb_l_set("debug", "2");
    kjb_l_set("page", "off");

    for (i = 0; i < num_tries; i++)
    {
        int    r;
        int    c;
        int    diff;
        int    num_rows = 1 + MAX_NUM_ROWS * kjb_rand();
        int    num_cols = 1 + MAX_NUM_COLS * kjb_rand();

        kjb_l_set("use-memcpy", "f");

        EPETE(get_random_matrix(&source_mp, num_rows, num_cols));
        EPETE(ow_subtract_scalar_from_matrix(source_mp, 0.5));
        EPETE(ow_multiply_matrix_by_scalar(source_mp, 10000.0));
        EPETE(copy_matrix_to_int_matrix(&mp, source_mp));

        r = kjb_rint((double)num_rows * kjb_rand());
        r = MIN_OF(r, num_rows - 1);

        c = kjb_rint((double)num_cols * kjb_rand());
        c = MIN_OF(c , num_cols - 1);

        ASSERT_IS_LESS_INT(r, num_rows);
        ASSERT_IS_LESS_INT(c, num_cols);

        mp->elements[ r ][ c ] = i;

        init_cpu_time();
        EPETE(copy_int_matrix(&mp2, mp));
        std_cpy_cpu += get_cpu_time(); 

        diff = max_abs_int_matrix_difference(mp, mp2);

        if (diff != 0) 
        {
            p_stderr("Max diff (%d) is not zero (without memcpy).\n", diff);
            return EXIT_FAILURE;
        }

        kjb_l_set("use-memcpy", "t");

        r = kjb_rint((double)num_rows * kjb_rand());
        r = MIN_OF(r, num_rows - 1);

        c = kjb_rint((double)num_cols * kjb_rand());
        c = MIN_OF(c , num_cols - 1);

        ASSERT_IS_LESS_INT(r, num_rows);
        ASSERT_IS_LESS_INT(c, num_cols);

        mp->elements[ r ][ c ] = i;

        init_cpu_time();
        EPETE(copy_int_matrix(&mp2, mp));
        memcpy_cpu += get_cpu_time(); 

        diff = max_abs_int_matrix_difference(mp, mp2);

        if (diff != 0) 
        {
            p_stderr("Max diff (%d) is not zero (memcpy).\n", diff);
            return EXIT_FAILURE;
        }
    }

    if (is_interactive())
    {
        dbi(std_cpy_cpu);
        dbi(memcpy_cpu);
    }

    free_matrix(source_mp); 
    free_int_matrix(mp); 
    free_int_matrix(mp2); 

    return EXIT_SUCCESS; 
}


#include "l/l_incl.h" 

#define CHECK_TRUE(X) \
\
    if ( ! (X) ) \
    { \
        p_stderr("FALIED: "#X" is true.\n");  \
        failure = TRUE; \
    } \
    else if (is_interactive()) \
    { \
        p_stderr("Passed: "#X" is true.\n");  \
    }



int main(int argc, char **argv)
{
    int    i;
    int    test_factor = 1; 
    int    failure = FALSE;


    kjb_init();

    if (argc > 1)
    {
        EPETE(ss1pi(argv[ 1 ], &test_factor)); 

        if (test_factor == 0) 
        {
            test_factor = 1;
        }
    }

    if (is_interactive())
    {
        kjb_set_debug_level(2);
    }
    else 
    {
        kjb_set_debug_level(0); 
    }

#ifdef MACHINE_CONSTANT_NOT_AVAILABLE
    p_stderr("Some machine constant is not available on this system.\n");
    failure = TRUE;
#else
    p_stderr("\nPassed: MACHINE_CONSTANT_NOT_AVAILABLE is not defined.\n\n");
#endif 

    CHECK_TRUE(IS_EQUAL_FLT(FLT_ZERO, FLT_ZERO));
    CHECK_TRUE(IS_NEARLY_EQUAL_FLT(FLT_ZERO, FLT_ZERO, FLT_EPSILON));
    CHECK_TRUE(IS_NEARLY_EQUAL_FLT(FLT_ZERO, FLT_ZERO, FLT_ZERO));

    CHECK_TRUE(IS_EQUAL_DBL(0.0, 0.0));
    CHECK_TRUE(IS_ZERO_DBL(0.0));
    CHECK_TRUE(IS_ZERO_DBL(DBL_MIN));
    CHECK_TRUE(IS_ZERO_DBL(-DBL_MIN));
    CHECK_TRUE( ! IS_ZERO_DBL(1.0));
    CHECK_TRUE( ! IS_ZERO_DBL(DBL_EPSILON / 10.0));
    CHECK_TRUE( ! IS_ZERO_DBL(DBL_MIN * 10.0));
    CHECK_TRUE(IS_NEARLY_EQUAL_DBL(0.0, 0.0, DBL_EPSILON));
    CHECK_TRUE(IS_NEARLY_EQUAL_DBL(0.0, 0.0, 0.0));

    CHECK_TRUE(! IS_EQUAL_DBL(1.0, 2.0));
    CHECK_TRUE(! IS_EQUAL_DBL(1.0, 1.00001));
    CHECK_TRUE(! IS_EQUAL_DBL(1.0, 1.0 + 10.0 * DBL_EPSILON));

    CHECK_TRUE(1e-15 > DBL_EPSILON); 
    CHECK_TRUE(0.0 < DBL_EPSILON); 
    CHECK_TRUE(1e-300 > DBL_MIN); 
    CHECK_TRUE(1e+300 < DBL_MAX); 

    CHECK_TRUE(SUB_RELATIVE_DBL(1.0, 2*DBL_EPSILON) < 1.0);
    CHECK_TRUE(SUB_RELATIVE_DBL(1.0, 2*DBL_EPSILON) > 1.0 - 5*DBL_EPSILON);
    CHECK_TRUE(ADD_RELATIVE_DBL(1.0, 2*DBL_EPSILON) > 1.0);
    CHECK_TRUE(ADD_RELATIVE_DBL(1.0, 2*DBL_EPSILON) < 1.0 + 5*DBL_EPSILON);

#ifdef DEF_OUT
    for (i = -test_factor * 1000; i< test_factor * 1000; i++)
    {
    }
#endif 

    kjb_cleanup();
    
    if (failure)
    {
        return EXIT_FAILURE;
    }
    else 
    {
        return EXIT_SUCCESS;
    }
}


#include "m/m_incl.h"

/*
#define VERBOSE           1
*/


#define NUM_LOOPS       50
#define BASE_NUM_TRIES  100


/*ARGSUSED*/
int main(int argc, char **argv)
{
    int num_rows;
    int num_cols; 
    int count;
    int  num_tries = BASE_NUM_TRIES;
    int  test_factor = 1;
    Matrix*   rand_mp = NULL; 
    Int_matrix* first_mp = NULL;
    Int_matrix* second_mp = NULL;
    Int_matrix* third_mp = NULL;
    Int_matrix* trans_mp = NULL;
    Int_vector* row_vp = NULL;
    Int_vector* col_vp = NULL;
    int result = EXIT_SUCCESS;


    kjb_init(); 

    if (argc > 1)
    {
        EPETE(ss1pi(argv[ 1 ], &test_factor)); 
    }

    if (test_factor == 0)
    {
        num_tries = 1;
    }
    else
    {
        num_tries *= test_factor;
    }


    for (count=0; count<num_tries; count++)
    {
        for (num_rows=1; num_rows<NUM_LOOPS; num_rows++)
        {
            for (num_cols=1; num_cols<NUM_LOOPS; num_cols++)
            {
                int  diff_1;
                int  diff_2;
                int  diff_3;
                int  i, j; 


                /*
                //   pso("%d %d %d\n", count, num_rows, num_cols);
                */   

                EPETE(get_random_matrix(&rand_mp, num_rows, num_cols));
                EPETE(ow_subtract_scalar_from_matrix(rand_mp, 0.5)); 
                EPETE(ow_multiply_matrix_by_scalar(rand_mp, 2000.0)); 
                EPETE(copy_matrix_to_int_matrix(&first_mp, rand_mp));
                EPETE(get_target_int_matrix(&second_mp, num_cols, num_rows));
                EPETE(get_target_int_matrix(&third_mp, num_cols, num_rows));
                EPETE(get_int_transpose(&trans_mp, first_mp));

#ifdef VERBOSE
                dbp("\n -------------------------------------------------- \n");
                db_mat(first_mp);
#endif 

                for (i=0; i<num_rows; i++)
                {
                    EPETE(get_int_matrix_row(&row_vp, first_mp, i));

#ifdef VERBOSE
                    db_rv(row_vp);
#endif 

                    EPETE(put_int_matrix_col(second_mp, row_vp, i));
                }

                for (j=0; j<num_cols; j++)
                {
                    EPETE(get_int_matrix_col(&col_vp, first_mp, j));

#ifdef VERBOSE
                    db_cv(col_vp);
#endif 

                    EPETE(put_int_matrix_row(third_mp, col_vp, j));
                }

#ifdef VERBOSE
                db_mat(trans_mp); 
                db_mat(second_mp);
                db_mat(third_mp);
#endif 

                diff_1 = max_abs_int_matrix_difference(trans_mp, second_mp);
                diff_2 = max_abs_int_matrix_difference(trans_mp, third_mp);

                EPETE(get_int_transpose(&trans_mp, trans_mp));
                diff_3 = max_abs_int_matrix_difference(trans_mp, first_mp);


                if (diff_1 != 0)
                {
                    p_stderr("Problem with first test (%d != 0).\n", diff_1);
                    result = EXIT_FAILURE;
                }

                if (diff_2 != 0)
                {
                    p_stderr("Problem with second test (%d != 0).\n", diff_2);
                    result = EXIT_FAILURE;
                }

                if (diff_3 != 0)
                {
                    p_stderr("Problem with third test (%d != 0).\n", diff_3);
                    result = EXIT_FAILURE;
                }
            }
        }
    }

    free_matrix(rand_mp); 
    free_int_vector(row_vp); 
    free_int_vector(col_vp); 
    free_int_matrix(first_mp);
    free_int_matrix(second_mp);
    free_int_matrix(third_mp); 
    free_int_matrix(trans_mp); 

    return result; 
}


#define BASE_NUM_TRIES  10000
#define MAX_DIM         200

#include "l/l_incl.h" 

int main(int argc, char **argv)
{
    int    try, i, j;
    int    test_factor = 1; 
    int num_tries = BASE_NUM_TRIES; 
    Int_matrix* mp = NULL; 
    int prev_num_rows;
    int prev_num_cols;


    kjb_init();

    if (argc > 1)
    {
        EPETE(ss1pi(argv[ 1 ], &test_factor)); 

        if (test_factor == 0) 
        {
            num_tries = 100;
        }
        else
        {
            num_tries *= test_factor;
        }
    }

    if (is_interactive())
    {
        kjb_set_debug_level(2); 
    }
    else 
    {
        kjb_set_debug_level(0); 
    }

    prev_num_rows = MAX_DIM / 10; 
    prev_num_cols = MAX_DIM / 10; 
    EPETE(ra_get_target_int_matrix(&mp, prev_num_rows, prev_num_cols));

    for (i = 0; i < mp->num_rows; i++)
    {
        for (j = 0; j < mp->num_cols; j++)
        {
            mp->elements[ i ][ j ] = i*j;
        }
    }

    for (try = 0; try< num_tries; try++)
    {
        int num_rows = MIN_OF(MAX_DIM - 1, 2.0 + (kjb_rand() * (double)MAX_DIM));
        int num_cols = MIN_OF(MAX_DIM - 1, 2.0 + (kjb_rand() * (double)MAX_DIM));

        if (try % 2 == 0)
        {
            num_cols = prev_num_cols; 
        }

        if (try % 7 == 0)
        {
            num_rows = 0;
        }

        if (try % 11 == 0)
        {
            num_cols = 0;
        }

        if (try % 13 == 0)
        {
            num_rows += 20 * MAX_DIM;
        }

        if (try % 17 == 0)
        {
            num_cols += 20 * MAX_DIM;
        }

#ifdef VERBOSE
        dbi(prev_num_rows);
        dbi(prev_num_cols);
        dbi(num_rows);
        dbi(num_cols);
        dbx(mp->elements); 

        if (mp->elements != NULL)
        {
            dbx(mp->elements[ 0 ]); 
        }

        dbi_mat(mp); 
#endif 

        EPETE(ra_get_target_int_matrix(&mp, num_rows, num_cols));

#ifdef VERBOSE
        dbi_mat(mp); 
#endif 

        for (i = 0; i < MIN_OF(num_rows, prev_num_rows); i++)
        {
            for (j = 0; j < MIN_OF(num_cols, prev_num_cols); j++)
            {
                if (mp->elements[ i ][ j ] != (try + i*j))
                {
                    dbi(mp->elements[ i ][ j ]); 
                    dbi(try + i*j); 
                    p_stderr("Preservation condition failed for element (%d, %d).\n", i, j);
                    return EXIT_FAILURE;
                }
            }
        }

#ifdef VERBOSE
        dbp("-----------------"); 
#endif 

        for (i = 0; i < mp->num_rows; i++)
        {
            for (j = 0; j < mp->num_cols; j++)
            {
                mp->elements[ i ][ j ] = 1 + try + i*j;
            }
        }

        prev_num_rows = num_rows;
        prev_num_cols = num_cols;
    }

    free_int_matrix(mp);

    kjb_cleanup();
    
    return EXIT_SUCCESS;
}


#define BASE_NUM_TRIES  1000
#define MAX_LEN         1000000

#include "l/l_incl.h" 

int main(int argc, char **argv)
{
    int    try, i;
    int    test_factor = 1; 
    int num_tries = BASE_NUM_TRIES; 
    Int_vector* vp = NULL; 
    int prev_len;


    kjb_init();

    if (argc > 1)
    {
        EPETE(ss1pi(argv[ 1 ], &test_factor)); 

        if (test_factor == 0) 
        {
            num_tries = 10;
        }
        else
        {
            num_tries *= test_factor;
        }
    }

    if (is_interactive())
    {
        kjb_set_debug_level(2); 
    }
    else 
    {
        kjb_set_debug_level(0); 
    }

    prev_len = 100; 
    EPETE(ra_get_target_int_vector(&vp, prev_len));

    for (i = 0; i < prev_len; i++)
    {
        vp->elements[ i ] = i;
    }

    for (try = 0; try< num_tries; try++)
    {
        int len = MIN_OF(MAX_LEN - 1, 2.0 + (kjb_rand() * (double)MAX_LEN));

        if (try % 5 == 0)
        {
            len += MIN_OF(try, 100) * MAX_LEN;
        }

        dbx(vp->elements); 

        EPETE(ra_get_target_int_vector(&vp, len));

        for (i = 0; i < MIN_OF(len, prev_len); i++)
        {
            if (vp->elements[ i ] != try + i)
            {
                p_stderr("Preservation condition failed.\n");
                return EXIT_FAILURE;
            }
        }

        for (i = 0; i < len; i++)
        {
            vp->elements[ i ] = 1 + try + i;
        }

        prev_len = len;
    }

    free_int_vector(vp);

    kjb_cleanup();
    
    return EXIT_SUCCESS;
}


#define BASE_NUM_TRIES  3000

#include "l/l_incl.h" 

int main(int argc, char **argv)
{
    double dx;
    float  fx;
    int    i, j;
    int    ri, kri, dri, dkri; 
    int    test_factor = 1; 
    IMPORT int kjb_debug_level;
    int result = EXIT_SUCCESS;
    int num_tries = BASE_NUM_TRIES; 


    kjb_init();

    if (argc > 1)
    {
        EPETE(ss1pi(argv[ 1 ], &test_factor)); 

        if (test_factor == 0) 
        {
            num_tries = 100;
        }
        else
        {
            num_tries *= test_factor;
        }
    }

    if (is_interactive())
    {
        kjb_debug_level = 2;
    }
    else 
    {
        kjb_debug_level = 0; 
    }

    for (i = -num_tries; i< num_tries; i++)
    {
        dbi(i); 

        dx = (double)i + 0.5;
        ri = rint(dx);
        kri = kjb_rint(dx);

        if (kri != ri)
        {
            set_error("Test 1: Problem rounding double %.3e (%d != %d).", 
                      dx, kri, ri);
            kjb_print_error();
            result = EXIT_FAILURE;
        }

        dx = (double)i - 0.5;
        ri = rint(dx);
        kri = kjb_rint(dx);

        if (kri != ri)
        {
            set_error("Test 2: Problem rounding double %.3e (%d != %d).", 
                      dx, kri, ri);
            kjb_print_error();
            result = EXIT_FAILURE;
        }

        for (j = 0; j < num_tries; j++)
        {
            dx = (double)i + kjb_rand();
            ri = rint(dx);
            kri = kjb_rint(dx);

            if (kri != ri)
            {
                set_error("Test 3: Problem rounding double %.3e (%d != %d).", 
                          dx, kri, ri);
                kjb_print_error();
                result = EXIT_FAILURE;
            }
        }

#ifdef __GNUC__

        /*
         * Not all systems have rintf(). GNU systems generally have it. Test
         * kjb_rintf() on those systems for now. 
        */

        fx = (float)i + 0.5f;
        ri = rintf(fx);
        kri = kjb_rintf(fx);
        dri = rint((double)fx);
        dkri = kjb_rint((double)fx); 

        if (kri != ri)
        {
            set_error("Test 4: Problem rounding float %.3e (%d != %d)    [ Double results are %d and %d ].", 
                      (double)fx, kri, ri, dkri, dri);
            kjb_print_error();
            result = EXIT_FAILURE;
        }

        fx = (float)i - 0.5f;
        ri = rintf(fx);
        kri = kjb_rintf(fx);
        dri = rint((double)fx);
        dkri = kjb_rint((double)fx); 

        if (kri != ri)
        {
            set_error("Test 5: Problem rounding float %.3e (%d != %d)    [ Double results are %d and %d ].", 
                      (double)fx, kri, ri, dkri, dri);
            kjb_print_error();
            result = EXIT_FAILURE;
        }

        for (j = 0; j < num_tries; j++)
        {
            fx = (float)i + (float)kjb_rand();
            ri = rintf(fx);
            kri = kjb_rintf(fx);
            dri = rint((double)fx);
            dkri = kjb_rint((double)fx); 

            if (kri != ri)
            {
                set_error("Test 6: Problem rounding float %.3e (%d != %d)    [ Double results are %d and %d ].", 
                      (double)fx, kri, ri, dkri, dri);
                kjb_print_error();
                result = EXIT_FAILURE;
            }
        }
#endif 
    }

    kjb_cleanup();
    
    return result;
}


#include "l/l_incl.h" 

#define BASE_NUM_TRIES  1

int main(int argc, char **argv)
{
    int    try, i;
    int    test_factor = 1; 
    int num_tries = BASE_NUM_TRIES; 
    Word_list* word_list_ptr = NULL; 

    kjb_init();

    /*
     * Boiler plate not yet relavant here.
    */

    if (argc > 1)
    {
        EPETE(ss1pi(argv[ 1 ], &test_factor)); 

        if (test_factor == 0) 
        {
            num_tries = 100;
        }
        else
        {
            num_tries *= test_factor;
        }
    }

    if (is_interactive())
    {
        kjb_set_debug_level(2); 
    }
    else 
    {
        kjb_set_debug_level(0); 
    }

    EPETE(read_word_list(&word_list_ptr, NULL));
    EPETE(write_word_list(word_list_ptr, NULL));

    free_word_list(word_list_ptr); 

    kjb_cleanup();
    
    return EXIT_SUCCESS;
}

